// 05/13/2025 (@davex)
// SPDX-License-Identifier: GPL-2.0-or-later

#include QMK_KEYBOARD_H
#include "print.h"
#include "features/layer_lock.h"

__attribute__ ((weak))
bool process_record_secrets(uint16_t keycode, keyrecord_t *record) {
  return true;
}
__attribute__ ((weak))
bool process_leader_secrets(void) {
  return true;
}

// set up something for eeprom persistent storage if the BASE/BASE2 layers should be for linux os
// this saves duplicating 2 entire keymap layouts (windows/linux will use the same keys)
typedef union {
    uint32_t raw;
    struct {
        bool is_linux_base :1;
    };
} user_config_t;
user_config_t user_config;

// layer identifiers
enum layers {
    BASE_LAYR,
    BASE2_LAYR,
    MAC_BASE_LAYR,
    MAC_BASE2_LAYR,
    FN_LAYR,
    SFT_LAYR,
    CTL_LAYR,
    TMUX_LAYR,
    SYMBOL_LAYR,
    MAC_SYMBOL_LAYR,
    WIDE_TEXT_LAYR,
    CIRCLE_TEXT_LAYR,
    LOCK_LAYR
};


// custom keycodes
enum custom_keycodes {
    BSPCFAST = NEW_SAFE_RANGE,
    ARROW,
    WAVE,
    LLOCK,
    DUAL_PLUSMIN,
    DUAL_MULTDIV,
    DUAL_F12,
    DUAL_F13,
    DUAL_ESC,
    VI_REPLACE,
    GIT_ADD,
    GIT_COMMIT,
    GIT_PUSH,
    GIT_CHKOUT,
    GIT_LOG,
    FJLIGHT,
    HROWLIGHT,
    KTRACK,
    BASE_CHG,
    MK_HOLD,
    MK_ACCEL0,
    MK_ACCEL2,
    TMUXLKEY,
    TMUXLCMD,
    TMONON,
    TMONOF,
    TVISON,
    TVISOF,
    TWINLFT,
    TWINRGT,
    TJPANE,
    LTRANS,
    OPT2,
    OPT3,
    OPT4,
    OPT5,
    OPT6,
    OPT7,
    OPT8,
    OPT9,
    OPT0,
    OPTMIN,
    OPTEQ,
    OPTQ,
    OPTW,
    OPTR,
    OPTT,
    OPTY,
    OPTO,
    OPTP,
    OPTLBR,
    OPTRBR,
    OPTBSL,
    OPTA,
    OPTS,
    OPTD,
    OPTF,
    OPTG,
    OPTH,
    OPTJ,
    OPTK,
    OPTL,
    OPTSEM,
    OPTAPO,
    OPTZ,
    OPTX,
    OPTC,
    OPTV,
    OPTB,
    OPTM,
    OPTCOM,
    OPTDOT,
    OPTSLS,
    SUITH,
    SUITD,
    SUITC,
    SUITS,
    SUP1,
    SUP2,
    SUP3,
    NBSP,
    CIRCL1,
    CIRCL2,
    CIRCL3,
    CIRCL4,
    CIRCL5,
    CIRCL6,
    CIRCL7,
    CIRCL8,
    CIRCL9,
    CIRCL0,
    CIRCLQ,
    CIRCLW,
    CIRCLE,
    CIRCLR,
    CIRCLT,
    CIRCLY,
    CIRCLU,
    CIRCLI,
    CIRCLO,
    CIRCLP,
    CIRCLA,
    CIRCLS,
    CIRCLD,
    CIRCLF,
    CIRCLG,
    CIRCLH,
    CIRCLJ,
    CIRCLK,
    CIRCLL,
    CIRCLZ,
    CIRCLX,
    CIRCLC,
    CIRCLV,
    CIRCLB,
    CIRCLN,
    CIRCLM,
    WM_SYM,
    STHRU,
    UNDERLN,
    BARTEXT,
    BBRTEXT,
    COLORTEST,
    FLASH_KB,
    BOOTLDR
};

// custom tap dances
enum {
    CAPS_LAYR = 0,
    FN_OSL = 1,
    RSFT_OSL = 2,
    RALT_OSL = 3,
    KB_UNLOCK = 4,
    ACT_GRV = 5,
    ACT_1   = 6,
    ACT_E   = 7,
    ACT_U   = 8,
    ACT_I   = 9,
    ACT_N   = 10,
    LGUI_OSL = 11,
    RCMD_OSL = 12,
    LOPT_OSL = 13
};


// all the keymaps with their defined keycodes
// clang-format off
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
//  [BASE_LAYR]
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |D_Esc |    | F1   || F2   || F3   || F4   |    | F5   || F6   || F7   || F8   |    | F9   || F10  || F11  || DF12 |    | Del  |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  | `    || 1    || 2    || 3    || 4    || 5    || 6    || 7    || 8    || 9    || 0    || -    || =    || Backspace    || Home |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  | LT(TMUX) || Q    || W    || E    || R    || T    || Y    || U    || I    || O    || P    || [    || ]    || \        || PgUp |  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  | TD(CAPS)    || A    || S    || D    || F    || G    || H    || J    || K    || L    || ;    || '    || Enter         || PgDn |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  | LShift          || Z    || X    || C    || V    || B    || N    || M    || ,    || .    || /    ||TD(RSFT)   || Up   || End  |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  | Ctrl    ||TD(GUI) || Alt     || Space                                        ||TD(RALT) ||TD(FN)   |  | Left || Down || Rght |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [BASE_LAYR] = LAYOUT_ansi(
        DUAL_ESC,   KC_F1,  KC_F2,  KC_F3,  KC_F4,      KC_F5,  KC_F6,  KC_F7,  KC_F8,      KC_F9, KC_F10, KC_F11, DUAL_F12,     KC_DEL,
        KC_GRV,  KC_1,   KC_2,   KC_3,   KC_4,   KC_5,   KC_6,   KC_7,   KC_8,   KC_9,   KC_0, KC_MINS, KC_EQL,   BSPCFAST,     KC_HOME,
        LT(TMUX_LAYR,KC_TAB),  KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y,   KC_U,   KC_I,   KC_O,   KC_P, KC_LBRC, KC_RBRC, KC_BSLS,   KC_PGUP,
        TD(CAPS_LAYR),  KC_A,   KC_S,   KC_D,   KC_F,   KC_G,   KC_H,   KC_J,    KC_K,  KC_L,  KC_SCLN, KC_QUOT,    KC_ENT,     KC_PGDN,
        KC_LSFT,            KC_Z,   KC_X,   KC_C,   KC_V,   KC_B,   KC_N,  KC_M, KC_COMM, KC_DOT, KC_SLSH, TD(RSFT_OSL), KC_UP,  KC_END,
        KC_LCTL, TD(LGUI_OSL), KC_LALT,                   KC_SPC,                   TD(RALT_OSL), TD(FN_OSL), KC_LEFT, KC_DOWN, KC_RGHT
    ),

//  [BASE2_LAYR]
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |D_Esc |    | F1   || F2   || F3   || F4   |    | F5   || F6   || F7   || F8   |    | F9   || F10  || F11  || F12  |    | DF13 |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  | `    || 1    || 2    || 3    || 4    || 5    || 6    || 7    || 8    || 9    || 0    || -    || =    || Backspace    ||Insert|  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  | LT(TMUX) || Q    || W    || E    || R    || T    || Y    || U    || I    || O    || P    || [    || ]    || \        ||Delete|  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  | TD(CAPS)    || A    || S    || D    || F    || G    || H    || J    || K    || L    || ;    || '    || Enter         || PgUp |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  | LShift          || Z    || X    || C    || V    || B    || N    || M    || ,    || .    || /    ||TD(RSFT)   || Up   || PgDn |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  | Ctrl    ||TD(GUI) || Alt     || Space                                        ||TD(RALT) ||TD(FN)   |  | Left || Down || Rght |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [BASE2_LAYR] = LAYOUT_ansi(
        DUAL_ESC,   KC_F1,  KC_F2,  KC_F3,  KC_F4,      KC_F5,  KC_F6,  KC_F7,  KC_F8,       KC_F9,  KC_F10, KC_F11, KC_F12,   DUAL_F13,
        KC_GRV,  KC_1,  KC_2,   KC_3,   KC_4,   KC_5,   KC_6,   KC_7,    KC_8,  KC_9,   KC_0,  KC_MINS, KC_EQL,   BSPCFAST,      KC_INS,
        LT(TMUX_LAYR,KC_TAB), KC_Q, KC_W, KC_E, KC_R, KC_T,  KC_Y,   KC_U,    KC_I,  KC_O,   KC_P, KC_LBRC, KC_RBRC,  KC_BSLS,   KC_DEL,
        TD(CAPS_LAYR),  KC_A,   KC_S,   KC_D,   KC_F,   KC_G,   KC_H,   KC_J,   KC_K,   KC_L, KC_SCLN, KC_QUOT,    KC_ENT,      KC_PGUP,
        KC_LSFT,            KC_Z,   KC_X,   KC_C,   KC_V,   KC_B,   KC_N,  KC_M, KC_COMM, KC_DOT, KC_SLSH, TD(RSFT_OSL), KC_UP, KC_PGDN,
        KC_LCTL, TD(LGUI_OSL), KC_LALT,                   KC_SPC,                   TD(RALT_OSL), TD(FN_OSL), KC_LEFT, KC_DOWN, KC_RGHT
    ),

//  [MAC_BASE_LAYR]
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |D_Esc |    | F1   || F2   || F3   || F4   |    | F5   || F6   || F7   || F8   |    | F9   || F10  || F11  || DF12 |    | Del  |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  | `    || 1    || 2    || 3    || 4    || 5    || 6    || 7    || 8    || 9    || 0    || -    || =    || Backspace    || Home |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  | LT(TMUX) || Q    || W    || E    || R    || T    || Y    || U    || I    || O    || P    || [    || ]    || \        || PgUp |  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  | TD(CAPS)    || A    || S    || D    || F    || G    || H    || J    || K    || L    || ;    || '    || Enter         || PgDn |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  | LShift          || Z    || X    || C    || V    || B    || N    || M    || ,    || .    || /    ||TD(RSFT)   || Up   || End  |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  | Ctrl    ||TD(LOPT)|| Command || Space                                        ||TD(RCMD) ||TD(FN)   |  | Left || Down || Rght |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [MAC_BASE_LAYR] = LAYOUT_ansi(
        DUAL_ESC,   KC_F1,  KC_F2,  KC_F3,  KC_F4,      KC_F5,  KC_F6,  KC_F7,  KC_F8,      KC_F9, KC_F10, KC_F11, DUAL_F12,     KC_DEL,
        KC_GRV,  KC_1,   KC_2,   KC_3,   KC_4,   KC_5,   KC_6,   KC_7,   KC_8,   KC_9,   KC_0, KC_MINS, KC_EQL,   BSPCFAST,     KC_HOME,
        LT(TMUX_LAYR,KC_TAB),  KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y,   KC_U,   KC_I,   KC_O,   KC_P, KC_LBRC, KC_RBRC, KC_BSLS,   KC_PGUP,
        TD(CAPS_LAYR),  KC_A,   KC_S,   KC_D,   KC_F,   KC_G,   KC_H,   KC_J,    KC_K,  KC_L,  KC_SCLN, KC_QUOT,    KC_ENT,     KC_PGDN,
        KC_LSFT,            KC_Z,   KC_X,   KC_C,   KC_V,   KC_B,   KC_N,  KC_M, KC_COMM, KC_DOT, KC_SLSH, TD(RSFT_OSL), KC_UP,  KC_END,
        KC_LCTL, TD(LOPT_OSL), KC_LCMD,                   KC_SPC,                   TD(RCMD_OSL), TD(FN_OSL), KC_LEFT, KC_DOWN, KC_RGHT
    ),

//  [MAC_BASE2_LAYR]
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |D_Esc |    | F1   || F2   || F3   || F4   |    | F5   || F6   || F7   || F8   |    | F9   || F10  || F11  || F12  |    | DF13 |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  | `    || 1    || 2    || 3    || 4    || 5    || 6    || 7    || 8    || 9    || 0    || -    || =    || Backspace    ||Insert|  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  | LT(TMUX) || Q    || W    || E    || R    || T    || Y    || U    || I    || O    || P    || [    || ]    || \        ||Delete|  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  | TD(CAPS)    || A    || S    || D    || F    || G    || H    || J    || K    || L    || ;    || '    || Enter         || PgUp |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  | LShift          || Z    || X    || C    || V    || B    || N    || M    || ,    || .    || /    ||TD(RSFT)   || Up   || PgDn |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  | Ctrl    ||TR(LOPT)|| Command || Space                                        ||TD(RCMD) ||TD(FN)   |  | Left || Down || Rght |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [MAC_BASE2_LAYR] = LAYOUT_ansi(
        DUAL_ESC,   KC_F1,  KC_F2,  KC_F3,  KC_F4,      KC_F5,  KC_F6,  KC_F7,  KC_F8,       KC_F9,  KC_F10, KC_F11, KC_F12,   DUAL_F13,
        KC_GRV,  KC_1,  KC_2,   KC_3,   KC_4,   KC_5,   KC_6,   KC_7,    KC_8,  KC_9,   KC_0,  KC_MINS, KC_EQL,   BSPCFAST,      KC_INS,
        LT(TMUX_LAYR,KC_TAB), KC_Q, KC_W, KC_E, KC_R, KC_T,  KC_Y,   KC_U,    KC_I,  KC_O,   KC_P, KC_LBRC, KC_RBRC,  KC_BSLS,   KC_DEL,
        TD(CAPS_LAYR),  KC_A,   KC_S,   KC_D,   KC_F,   KC_G,   KC_H,   KC_J,   KC_K,   KC_L, KC_SCLN, KC_QUOT,    KC_ENT,      KC_PGUP,
        KC_LSFT,            KC_Z,   KC_X,   KC_C,   KC_V,   KC_B,   KC_N,  KC_M, KC_COMM, KC_DOT, KC_SLSH, TD(RSFT_OSL), KC_UP, KC_PGDN,
        KC_LCTL, TD(LOPT_OSL), KC_LCMD,                   KC_SPC,                   TD(RCMD_OSL), TD(FN_OSL), KC_LEFT, KC_DOWN, KC_RGHT
    ),

//  [FN_LAYR] (green)
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |      |    |      ||      ||ViRepl||      |    |ChkOut||      ||      ||GitLog|    |GitAdd||Commit||      || Push |    |LLock |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  |      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||Arrow || Wave ||              ||SLock |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  | MO(TMUX) ||WMail2||WMail1||Mail  ||RPhone||WPhone||      ||      ||      ||      ||      || Rec1 || Rec2 ||          ||      |  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  |             ||Addr  ||City  ||ZIP   ||Phone ||      ||      ||      ||      || Lead ||      || PScr ||               ||HomIns|  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  | MO(SFT)         ||      ||Rout  ||Acct  ||      ||      ||      ||      || Ply1 || Ply2 ||Pause || MO(SFT)   ||      ||EndDel|  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  |         || WM_SYM || MO(CTL) || Space                                        || MO(CTL) ||         |  |      ||      ||      |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [FN_LAYR] = LAYOUT_ansi(
        _______,_______,_______, VI_REPLACE,_______, GIT_CHKOUT, _______,_______, GIT_LOG, GIT_ADD, GIT_COMMIT,_______, GIT_PUSH,  LLOCK,
        _______,_______,_______,_______, _______, _______, _______, _______, _______, _______, _______, ARROW, WAVE,  _______,   KC_SCRL,
        MO(TMUX_LAYR),SECRET3,SECRET2,SECRET1,SECRET8,SECRET9,_______,_______,_______,_______,_______,DM_REC1, DM_REC2, _______, _______,
        _______,SECRET4,SECRET5,SECRET6, SECRET7, _______, _______, _______, _______, QK_LEAD, _______, KC_PSCR,        _______, KC_HOME,
        MO(SFT_LAYR),_______,SECRET10,SECRET11,_______,_______,_______,_______,DM_PLY1, DM_PLY2, KC_PAUS, MO(SFT_LAYR), _______,  KC_END,
        _______,  WM_SYM, MO(CTL_LAYR),                  _______,                    MO(CTL_LAYR), _______,    _______, _______, _______
    ),

//  [SFT_LAYR] (yellow/orange)
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |      |    |MyComp||      || Calc || Menu |    |      || Prev || Play || Next |    |      || Mute || Vol- || Vol+ |    |LLock |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  |      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||              || Num  |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  |          ||      ||      ||      ||      ||      ||      ||  P7  ||  P8  ||  P9  || +  - ||      ||      ||          ||      |  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  |             ||      ||      ||      ||      ||      ||      ||  P4  ||  P5  ||  P6  || *  / ||      ||               ||MSHold|  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  |                 ||MSAcl2||      ||      ||      ||      ||      ||  P1  ||  P2  ||  P3  ||      ||           || MSUp || RClk |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  |         ||        || MSAcl0  ||                       P0                     ||   P.    ||   LClk  |  |MSLft || MSDn ||MSRgt |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [SFT_LAYR] = LAYOUT_ansi(
        _______,KC_MYCM,_______, KC_CALC, KC_APP, _______, KC_MPRV, KC_MPLY, KC_MNXT, _______, KC_MUTE, KC_VOLD, KC_VOLU,          LLOCK,
        _______,_______,_______,_______,_______, _______, _______, _______, _______, _______, _______, _______, _______, _______, KC_NUM,
        _______,_______,_______,_______,_______, _______, _______, KC_P7, KC_P8, KC_P9, DUAL_PLUSMIN, _______, _______, _______, _______,
        _______,_______,_______,_______,_______, _______, _______, KC_P4, KC_P5, KC_P6, DUAL_MULTDIV, _______,         _______,  MK_HOLD,
        _______,MK_ACCEL2, _______,_______,_______,_______,_______, KC_P1, KC_P2, KC_P3, _______,          _______, KC_MS_UP, KC_MS_BTN2,
        _______,_______, MK_ACCEL0,                     KC_P0,                  KC_PDOT, KC_MS_BTN1, KC_MS_LEFT, KC_MS_DOWN, KC_MS_RIGHT
    ),

//  [CTL_LAYR] (red)
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |      |    |RMode+||RMode-||      ||      |    |RHue+ ||RHue- ||RSat+ ||RSat- |    |      ||      ||ClrTst||Debug |    |LLock |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  | USB  || BT1  || BT2  || BT3  || 2.4G ||      ||      ||      ||      ||      ||      ||      ||      ||              ||      |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  |          ||      ||      ||      ||Reboot||      ||      ||      ||      ||      ||      ||      ||      || ChngBase ||RGBTog|  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  |             ||      ||      ||      ||Flash ||      ||      ||      ||      ||      ||KTrack||FJLite|| HomeRowLight  ||      |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  |                 ||      ||      ||EClear||      ||BootLd||      ||      ||      ||      ||      ||           ||RBri+ ||      |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  |         ||        ||         ||            Battery Level Check               ||         ||         |  |RSpd- ||RBri- ||RSpd+ |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [CTL_LAYR] = LAYOUT_ansi(
        _______, RGB_MOD, RGB_RMOD, _______, _______, RGB_HUI, RGB_HUD, RGB_SAI, RGB_SAD,  _______, _______, COLORTEST, DB_TOGG,   LLOCK,
        KC_USB, KC_BT1, KC_BT2, KC_BT3, KC_2G4, _______,_______,_______, _______, _______, _______, _______, _______, _______,   _______,
        _______,_______,_______,_______, QK_RBT, _______,_______,_______, _______, _______, _______, _______, _______, BASE_CHG, RGB_TOG,
        _______,_______,_______,_______, FLASH_KB, _______,_______,_______, _______, _______, KTRACK, FJLIGHT,   HROWLIGHT,      _______,
        _______,_______,_______, EE_CLR, _______, BOOTLDR, _______,_______,_______, _______, _______,          _______, RGB_VAI, _______,
        _______,_______,_______,                          KC_BATQ,                     _______, _______,       RGB_SPD, RGB_VAD, RGB_SPI
    ),

//  [TMUX_LAYR] (cyan)
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |      |    |TLEKY ||TLCMD ||      ||      |    |TMONON||TMONOF||TVISON||TVISOF|    |TJPANE||      ||WINLFT||WINRGT|    |LLock |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  |      ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||              ||      |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  |          ||LTRANS||LTRANS||      ||      ||LTRANS||      ||      ||      ||LTRANS||LTRANS||LTRANS||LTRANS||          ||      |  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  |             ||      ||LTRANS||LTRANS||      ||      ||      ||      ||      ||LTRANS||LTRANS||LTRANS||               ||LTRANS|  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  |                 ||LTRANS||LTRANS||LTRANS||      ||      ||LTRANS||      ||LTRANS||LTRANS||LTRANS||           ||LTRANS||      |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  |         ||        ||  LALT   ||                   LTRANS                     ||  LALT   ||         |  |LTRANS||LTRANS||LTRANS|  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [TMUX_LAYR] = LAYOUT_ansi(
        _______, TMUXLKEY, TMUXLCMD, _______, _______,  TMONON, TMONOF, TVISON, TVISOF,  TJPANE, _______, TWINLFT, TWINRGT,     LLOCK,
        _______, LTRANS,LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,     _______,  _______,
        _______,    LTRANS,LTRANS, _______,_______,LTRANS,_______,_______,_______,LTRANS, LTRANS, LTRANS, LTRANS, _______,    _______,
        _______,        _______,LTRANS,LTRANS, _______,_______,_______,_______,_______, LTRANS, LTRANS, LTRANS,     _______,   LTRANS,
        _______,          LTRANS, LTRANS, LTRANS, _______,_______, LTRANS, _______,LTRANS,LTRANS,LTRANS,    _______,  LTRANS, _______,
        _______,    _______,  KC_LALT,                      LTRANS,                      KC_LALT,  _______,  LTRANS,  LTRANS,  LTRANS
    ),

//  [SYMBOL_LAYR] (blue)
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |      |    | SUP1 || SUP2 || SUP3 ||      |    |SUITH ||SUITD ||SUITC ||SUITS |    |CIRCLI||      ||      || NBSP |    |LLock |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  |TD(G) ||TD(O1)||OPT2  ||OPT3  ||OPT4  ||OPT5  ||OPT6  ||OPT7  ||OPT8  ||OPT9  ||OPT0  ||OPTMIN||OPTEQ ||              ||      |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  |          ||OPTQ  ||OPTW  ||TD(E) ||OPTR  ||OPTT  ||OPTY  ||TD(U) ||TD(I) ||OPTO  ||OPTP  ||OPTLBR||OPTRBR||OPTBSL    ||      |  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  |             ||OPTA  ||OPTS  ||OPTD  ||OPTF  ||OPTG  ||OPTH  ||OPTJ  ||OPTK  ||OPTL  ||OPTSEM||OPTAPO||               ||      |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  |                 ||OPTZ  ||OPTX  ||OPTC  ||OPTV  ||OPTB  ||TD(N) ||OPTM  ||OPTCOM||OPTDOT||OPTSLS||           ||      ||      |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  |         ||        ||         ||                                              ||         ||         |  |      ||      ||      |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [SYMBOL_LAYR] = LAYOUT_ansi(
        _______,     SUP1,   SUP2,   SUP3, _______,     SUITH,  SUITD,  SUITC,  SUITS,     CIRCLI, _______, _______, NBSP,        LLOCK,
        TD(ACT_GRV), TD(ACT_1), OPT2, OPT3, OPT4, OPT5,  OPT6,   OPT7,  OPT8,   OPT9,  OPT0,   OPTMIN,  OPTEQ,       _______,   _______,
        _______,    OPTQ,  OPTW, TD(ACT_E), OPTR,  OPTT,   OPTY, TD(ACT_U), TD(ACT_I), OPTO, OPTP,  OPTLBR,  OPTRBR, OPTBSL,    _______,
        _______,        OPTA,  OPTS,  OPTD,  OPTF,   OPTG,     OPTH,   OPTJ,   OPTK,   OPTL,   OPTSEM, OPTAPO,      _______,    _______,
        _______,           OPTZ,  OPTX,  OPTC,   OPTV,   OPTB, TD(ACT_N),  OPTM,   OPTCOM,  OPTDOT, OPTSLS,   _______, _______, _______,
        _______,    _______,  _______,                      _______,                    _______,   _______,   _______, _______, _______
    ),


//  [MAC_SYMBOL_LAYR] (blue)
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |      |    | SUP1 || SUP2 || SUP3 ||      |    |SUITH ||SUITD ||SUITC ||SUITS |    |CIRCLI||      ||      || NBSP |    |LLock |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  |LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||              ||      |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  |          ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS    ||      |  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  |             ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||               ||      |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  |    LShift       ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||  RShift   ||      ||      |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  |         ||        ||         ||                                              ||         ||         |  |      ||      ||      |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [MAC_SYMBOL_LAYR] = LAYOUT_ansi(
        _______,     SUP1,   SUP2,   SUP3, _______,     SUITH,  SUITD,  SUITC,  SUITS,     CIRCLI, _______, _______, NBSP,        LLOCK,
        LTRANS,  LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,      _______,  _______,
        _______,     LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS ,LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,    _______,
        _______,         LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,     _______,   _______,
        KC_LSFT,           LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,    KC_RSFT, _______, _______,
        _______,  _______,  _______,                        _______,                      _______,  _______,  _______, _______, _______
    ),

//  [WIDE_TEXT_LAYR] (purple)
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |      |    |      ||      ||      ||      |    |      ||      ||      ||      |    |      ||      ||      ||      |    |LLock |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  |LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||              ||BBrTxt|  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  |          ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS    ||BarTxt|  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  |             ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||               ||SThru |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  |                 ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||           ||      ||UnderL|  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  |         ||        ||         ||                                              ||         ||         |  |      ||      ||      |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [WIDE_TEXT_LAYR] = LAYOUT_ansi(
        _______, _______, _______, _______, _______,  _______, _______, _______, _______,  _______, _______, _______, _______,    LLOCK,
        LTRANS,  LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,      _______,  BBRTEXT,
        _______,     LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS ,LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,    BARTEXT,
        _______,         LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,     _______,     STHRU,
        _______,           LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,    _______, _______, UNDERLN,
        _______,  _______,  _______,                        LTRANS,                      _______,  _______,   _______, _______, _______
    ),

//  [CIRCLE_TEXT_LAYR] (coral)
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |      |    |      ||      ||      ||      |    |      ||      ||      ||      |    |      ||      ||      ||      |    |LLock |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  |      ||CIRCL1||CIRCL2||CIRCL3||CIRCL4||CIRCL5||CIRCL6||CIRCL7||CIRCL8||CIRCL9||CIRCL0||      ||      ||              ||      |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  |          ||CIRCLQ||CIRCLW||CIRCLE||CIRCLR||CIRCLT||CIRCLY||CIRCLU||CIRCLI||CIRCLO||CIRCLP||      ||      ||          ||      |  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  |             ||CIRCLA||CIRCLS||CIRCLD||CIRCLF||CIRCLG||CIRCLH||CIRCLJ||CIRCLK||CIRCLL||      ||      ||               ||      |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  |                 ||CIRCLZ||CIRCLX||CIRCLC||CIRCLV||CIRCLB||CIRCLN||CIRCLM||      ||      ||      ||           ||      ||      |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  |         ||        ||         ||                                              ||         ||         |  |      ||      ||      |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [CIRCLE_TEXT_LAYR] = LAYOUT_ansi(
        _______, _______, _______, _______, _______,  _______, _______, _______, _______,  _______, _______, _______, _______,    LLOCK,
        _______,  CIRCL1, CIRCL2, CIRCL3, CIRCL4, CIRCL5, CIRCL6, CIRCL7, CIRCL8, CIRCL9, CIRCL0, _______, _______,    _______, _______,
        _______,     CIRCLQ, CIRCLW, CIRCLE, CIRCLR, CIRCLT, CIRCLY, CIRCLU, CIRCLI ,CIRCLO, CIRCLP, _______, _______, _______, _______,
        _______,         CIRCLA, CIRCLS, CIRCLD, CIRCLF, CIRCLG, CIRCLH, CIRCLJ, CIRCLK, CIRCLL, _______, _______,     _______, _______,
        _______,           CIRCLZ, CIRCLX, CIRCLC, CIRCLV, CIRCLB, CIRCLN, CIRCLM, _______, _______, _______, _______, _______, _______,
        _______,  _______,  _______,                        _______,                      _______,  _______,  _______, _______, _______
    ),

//  [LOCK_LAYR]
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |  No  |    |  No  ||  No  ||  No  ||  No  |    |  No  ||  No  ||  No  ||  No  |    |  No  ||  No  ||  No  ||  No  |    |TDUnlk|  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  |  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||      No      ||  No  |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  |    No    ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||    No    ||  No  |  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  |     No      ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||      No       ||  No  |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  |       No        ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||    No     ||  No  ||  No  |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  |   No    ||   No   ||   No    ||                      No                      ||   No    ||   No    |  |  No  ||  No  ||  No  |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
    [LOCK_LAYR] = LAYOUT_ansi(
        KC_NO,       KC_NO, KC_NO,  KC_NO,  KC_NO,      KC_NO,  KC_NO,  KC_NO,  KC_NO,     KC_NO,  KC_NO,  KC_NO,  KC_NO,  TD(KB_UNLOCK),
        KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,      KC_NO,       KC_NO,
        KC_NO,       KC_NO, KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,    KC_NO,     KC_NO,
        KC_NO,          KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,       KC_NO,      KC_NO,
        KC_NO,             KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,     KC_NO,     KC_NO,  KC_NO,
        KC_NO,      KC_NO,    KC_NO,                        KC_NO,                        KC_NO,     KC_NO,      KC_NO,  KC_NO,  KC_NO
    )
};

//  <~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>
//  ~=~=~=~=~=~=~=~=~=~=~=~ LED Indexes ~=~=~=~=~=~=~=~=~=~=~=~
// ,------------------------------------------------------------------------------------------------------------------------------------,
// :   ______      ______________________________      ______________________________      ______________________________      ______   :
// :  |  0   |    |  1   ||  2   ||  3   ||  4   |    |  5   ||  6   ||  7   ||  8   |    |  9   ||  10  ||  11  ||  12  |    |  13  |  :
// :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
// :   ______________________________________________________________________________________________________________________________   :
// :  |  14  ||  15  ||  16  ||  17  ||  18  ||  19  ||  20  ||  21  ||  22  ||  23  ||  24  ||  25  ||  26  ||      27      ||  28  |  :
// :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
// :  |    29    ||  30  ||  31  ||  32  ||  33  ||  34  ||  35  ||  36  ||  37  ||  38  ||  39  ||  40  ||  41  ||    42    ||  43  |  :
// :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
// :  |     44      ||  45  ||  46  ||  47  ||  48  ||  49  ||  50  ||  51  ||  52  ||  53  ||  54  ||  55  ||      56       ||  57  |  :
// :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
// :  |       58        ||  59  ||  60  ||  61  ||  62  ||  63  ||  64  ||  65  ||  66  ||  67  ||  68  ||    69     ||  70  ||  71  |  :
// :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
// :  |   72    ||   73   ||   74    ||                      75                      ||   76    ||   77    |  |  78  ||  79  ||  80  |  :
// :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
// `------------------------------------------------------------------------------------------------------------------------------------`
// useful key indexes
enum key_indexes {
    I_INDICATOR = 0,
    I_ESC = 0,
    I_LLOCK = 13,
    I_GRV = 14,
    I_1 = 15,
    I_2 = 16,
    I_3 = 17,
    I_4 = 18,
    I_5 = 19,
    I_6 = 20,
    I_7 = 21,
    I_8 = 22,
    I_9 = 23,
    I_0 = 24,    
    I_MIN = 25,
    I_PLUS = 26,
    I_INSHOME = 28,
    I_NUMLOCK = 28,
    I_SLOCK = 28,
    I_BBRTEXT = 28,
    I_TAB = 29,
    I_Q = 30,
    I_W = 31,
    I_E = 32,
    I_R = 33,
    I_T = 34,
    I_Y = 35,
    I_U = 36,
    I_I = 37,
    I_O = 38,
    I_P = 39,
    I_MREC1 = 40,
    I_MREC2 = 41,
    I_DELPGUP = 43,
    I_BARTEXT = 43,
    I_CAPS = 44,
    I_A = 45,
    I_S = 46,
    I_D = 47,
    I_F = 48,
    I_G = 49,
    I_H = 50,
    I_J = 51,
    I_K = 52,
    I_L = 53,
    I_SEMI = 54,
    I_KTRACK = 54,
    I_FJLIGHT = 55,
    I_HROWLIGHT = 56,
    I_PGUPPGDN = 57,
    I_STHRU = 57,
    I_LSFT = 58,
    I_Z = 59,
    I_X = 60,
    I_C = 61,
    I_V = 62,
    I_B = 63,
    I_N = 64,
    I_M = 65,
    I_COMMA = 66,
    I_MPLY1 = 66,
    I_MPLY2 = 67,
    I_DOT = 67,
    I_RSFT = 69,
    I_UP = 70,
    I_PGDNEND = 71,
    I_UNDERLN = 71,
    I_LCTL = 72,
    I_LGUI = 73,
    I_LOPT = 73,
    I_LALT = 74,
    I_LCMD = 74,
    I_RALT = 76,
    I_RCMD = 76,
    I_FN = 77,
    I_LEFT = 78,
    I_DOWN = 79,
    I_RIGHT = 80
};

// led indexes for keys that get capitalized when caps lock is on
bool is_capslock_shifted(uint8_t i) {
    if ((i > 29 && i < 40) || (i > 44 && i < 54) || (i > 58 && i < 66)) {
        return true;
    }
    return false;
}
// led indexes for keys that get shifted when caps word is on
bool is_capsword_shifted(uint8_t i) {
    if (i == 25 || is_capslock_shifted(i)) {
        return true;
    }
    return false;
}

// tap dance setup
typedef struct {
    bool is_press_action;
    int state;
} tap;
// tap dance states
enum {
    SINGLE_TAP = 1,
    SINGLE_HOLD = 2,
    DOUBLE_TAP = 3,
    DOUBLE_HOLD = 4,
    TRIPLE_TAP = 5,
    QUAD_TAP = 6,
    PENT_TAP = 7,
    HEXA_TAP = 8
};
// functions associated with all tap dances
int cur_dance (tap_dance_state_t *state);
// functions associated with individual tap dances
void caps_finished (tap_dance_state_t *state, void *user_data);
void caps_reset (tap_dance_state_t *state, void *user_data);
void ralt_finished (tap_dance_state_t *state, void *user_data);
void ralt_reset (tap_dance_state_t *state, void *user_data);
void fn_finished (tap_dance_state_t *state, void *user_data);
void fn_reset (tap_dance_state_t *state, void *user_data);
void rsft_finished (tap_dance_state_t *state, void *user_data);
void rsft_reset (tap_dance_state_t *state, void *user_data);
void kbunlock_finished (tap_dance_state_t *state, void *user_data);
void kbunlock_reset (tap_dance_state_t *state, void *user_data);
void actgrv_finished (tap_dance_state_t *state, void *user_data);
void actgrv_reset (tap_dance_state_t *state, void *user_data);
void act1_finished (tap_dance_state_t *state, void *user_data);
void act1_reset (tap_dance_state_t *state, void *user_data);
void acte_finished (tap_dance_state_t *state, void *user_data);
void acte_reset (tap_dance_state_t *state, void *user_data);
void actu_finished (tap_dance_state_t *state, void *user_data);
void actu_reset (tap_dance_state_t *state, void *user_data);
void acti_finished (tap_dance_state_t *state, void *user_data);
void acti_reset (tap_dance_state_t *state, void *user_data);
void actn_finished (tap_dance_state_t *state, void *user_data);
void actn_reset (tap_dance_state_t *state, void *user_data);
void lgui_finished (tap_dance_state_t *state, void *user_data);
void lgui_reset (tap_dance_state_t *state, void *user_data);
void rcmd_finished (tap_dance_state_t *state, void *user_data);
void rcmd_reset (tap_dance_state_t *state, void *user_data);
void lopt_finished (tap_dance_state_t *state, void *user_data);
void lopt_reset (tap_dance_state_t *state, void *user_data);

// key tracker
typedef struct {
    uint8_t index;
    bool press;
    int fade;
} keytracker;

// function for determining if a key should fade
bool key_should_fade(keytracker key, uint8_t layer);

// setup keytracker
static deferred_token key_token = INVALID_DEFERRED_TOKEN;
static keytracker tracked_keys[20];
static int tk_length = sizeof(tracked_keys) / sizeof(tracked_keys[0]);

// for tracking if leader sequence is started
bool is_in_leader_sequence;
bool is_leader_led_on;
static uint16_t leader_timer;
bool is_leader_error;
bool is_leader_error_led_on;
static uint16_t leader_error_timer;

// setup a way to delay oneshot deactivation after a keycode that keeps oneshot active
// a one-shot extended time can be simulated by simply turning a layer on and using the
// callback to turn the layer off after a specified delay
bool sim_osl;
static deferred_token sim_osl_token = INVALID_DEFERRED_TOKEN;
uint32_t sim_osl_callback(uint32_t trigger_time, void* cb_arg) {
    dprintf("sim_osl_callback running\n");
    uint8_t layer = get_highest_layer(layer_state);
    if (!is_layer_locked(layer)) {
        layer_off(layer);
    }
    sim_osl = false;
    return 0;
}

// if a leader seuqence errored, rgbs can be set to blink for a time until this callback is used 
static deferred_token leader_error_token = INVALID_DEFERRED_TOKEN;
uint32_t leader_error_callback(uint32_t trigger_time, void* cb_arg) {
    is_leader_error = false;
    is_leader_error_led_on = false;
    return 0;
}

// for tracking whether to highlight home row keys f and j
bool fj_light;
// and for tracking if the full home row light is on
bool hrow_light;
// for disabling the keytracker, which will also disable key-reactive fade
bool enable_keytracker = true;

// for tracking whether to blink an led as an indicator, used to show which layer is active
bool is_led_on;
static uint16_t layer_timer;

// for tracking layer lock in order to flash the layer lock indicator
bool is_layer_lock_led_on;
static uint16_t layer_lock_timer;

// for tracking key lock blinking
bool is_key_lock_led_on;
static uint16_t key_lock_timer;

// for tracking a recording macro
int8_t macro_direction;
bool macro_recording;
bool is_macro_led_on;
static uint16_t macro_timer;
// and a delayed callback after playing a dynamic macro from osl
static deferred_token osl_macro_token = INVALID_DEFERRED_TOKEN;
// callback for when a dynamic mcaro on fn osl is run (to turn off the layer)
uint32_t osl_macro_callback(uint32_t trigger_time, void *cb_arg) {
    layer_off(FN_LAYR);
    return 0;
}

// funciton to send an alternate key if a modifier is being held
void dual_key(uint16_t std_keycode, uint16_t alt_keycode, uint8_t mod_mask);

// function to send symbols normally requiring alt codes in ms windows
void symbol_key(const char *alt_code, const char *shift_alt_code, bool is_tap_dance);
// function to send symbols normally requiring hex codes in linux
void symbol_key_linux(const char *hex_code, const char *shift_hex_code);
// function to send symbols normally requiring unicode input in macos
void symbol_key_mac(const char *unicode, const char *shift_unicode); 
// and to type a string of numbers using the numpad (created for windows alt codes)
void type_numpad_keys_from_string(const char *stringnum);

// for tracking if oneshot layer is active
bool oneshot_layer_active;

// for tracking if a wireless indicator should show on any layer
// this gets set and elapsed time is tracked after a wireless or battery keycode is used
uint32_t wls_action_timer;

// if rgb color-test is requested, set this bool
bool color_test;
// and use a timer so that it can be turned off after a delay even if no further key is pressed
static uint16_t color_test_timer;

// for tracking if the base layer was changed in order to flash some indicators
bool base_layer_changed;
static uint16_t base_change_timer;
bool os_changed;
static uint16_t os_change_timer;

// for tracking if an accent char tap dance should light up a particular key to show what the tap will send
int act_char_led_index = 0;

// for tracking if base is mac
bool is_mac_base(void) {
    return (IS_LAYER_ON(MAC_BASE2_LAYR) || IS_LAYER_ON(MAC_BASE_LAYR)); 
}
// use this to highlight keyboard shortcuts with rgb when winkey (or linux super) is held
// split some of these into another color since they are used rarely
bool is_winkey_held;
int winkey_scut_keys[] = {I_INDICATOR, I_0, I_1, I_2, I_3, I_4, I_5, I_6, I_7, I_8, I_9, I_TAB, I_Q, I_E, I_R, I_A, I_D, I_L,
                          I_X, I_B, I_N, I_LEFT, I_RIGHT, I_UP, I_DOWN};
int winkey_scut_altcolor[] = {I_MIN, I_PLUS, I_T, I_U, I_I, I_P, I_S, I_F, I_G, I_H, I_K, I_SEMI, I_Z, I_V, I_M, I_COMMA, I_DOT};
int winkey_scut_keys_size = sizeof(winkey_scut_keys) / sizeof(winkey_scut_keys[0]);
int winkey_scut_altcolor_size = sizeof(winkey_scut_altcolor) / sizeof(winkey_scut_altcolor[0]);
int super_scut_keys[] = {I_INDICATOR, I_1, I_2, I_3, I_4, I_5, I_6, I_7, I_8, I_9, I_0, I_TAB, I_Q, I_A, I_D, I_L, I_PGUPPGDN, I_PGDNEND, I_V};
int super_scut_altcolor[] = {I_GRV, I_UP, I_DOWN, I_LEFT, I_RIGHT};
int super_scut_keys_size = sizeof(super_scut_keys) / sizeof(super_scut_keys[0]);
int super_scut_altcolor_size = sizeof(super_scut_altcolor) / sizeof(super_scut_altcolor[0]);

// this was originally a static declaration in the switch case for MK_HOLD, but I also want to use it outside of
// that switch case to do rgb change, so am moving it here.
bool ms_btn_held = false;

// for tracking wide-text options for the WIDE_TEXT_LAYR
enum {
    WIDE_STANDARD,
    WIDE_STHRU,
    WIDE_UNDERLN,
    WIDE_BARTEXT,
    WIDE_BBRTEXT
};
uint8_t wide_text_mode = WIDE_STANDARD;
bool wide_firstchar = false;

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    static uint32_t key_timer;
    // stop color test if active and a key is pressed
    if (color_test && record->event.pressed) {
        color_test = false;
        return false;
    }
    // record key index pressed for rgb reactive changes
    if (enable_keytracker && !is_macro_playing) {
        int key_idx = g_led_config.matrix_co[record->event.key.row][record->event.key.col];
        if (record->event.pressed) {
            dprintf("%u \n", key_idx);
            for (int i = tk_length - 1; i > 0; i--) {
                tracked_keys[i] = tracked_keys[i-1];
                if (tracked_keys[i].index == key_idx) {
                    tracked_keys[i].press = true;
                    tracked_keys[i].fade = 255;
                }
            }
            tracked_keys[0].press = true;
            tracked_keys[0].fade = 255;
            tracked_keys[0].index = key_idx;
        }
        else {
            for (int i = 0; i < tk_length; i++) {
                if (tracked_keys[i].index == key_idx) {
                    tracked_keys[i].press = false;
                    tracked_keys[i].fade = 119;
                }
            }
            // setup the key fade
            if (key_token) {
                cancel_deferred_exec(key_token);
                key_token = INVALID_DEFERRED_TOKEN;
            }
            uint32_t keytracker_callback(uint32_t trigger_time, void* cb_arg) {
                bool fade_changed = false;
                for (int i = 0; i < tk_length; i++) {
                    if (!tracked_keys[i].press && tracked_keys[i].fade > 0) {
                        tracked_keys[i].fade--;
                        fade_changed = true;
                    }
                }
                if (fade_changed) {
                    return 12;  // Call the callback every 12ms
                }
                else {
                    return 0;
                }
            }
            key_token = defer_exec(10, keytracker_callback, NULL);  // Schedule callback.
        }
    }
    // layer lock
    if (!process_layer_lock(keycode, record, LLOCK)) {
       return false;
    }

    switch (keycode) {
    // this is a custom version of KC_TRANS to press a key on default layer
    // setup so that I can use LTRANS in the keymap to denote which fallthrough keys get lit up on the layer
    case LTRANS:
        if (record->event.pressed) {
            uint8_t layer = get_highest_layer(layer_state);
            const uint8_t mods = get_mods();
            // prefix to send for the TMUX_LAYR
            if (layer == TMUX_LAYR) {
                unregister_mods(mods); // temp remove mods
                tap_code16(C(KC_B));   // send ctrl-b before keycode processing
                register_mods(mods);   // reapply mods
            }

            // for some wide modes, should start with the spacing char
            if (layer == WIDE_TEXT_LAYR && wide_firstchar) {
                unregister_mods(mods); // temp remove mods
                switch (wide_text_mode) {
                case WIDE_STHRU:
                    tap_code16(KC_MINS);
                    break;
                case WIDE_UNDERLN:
                    tap_code16(KC_UNDS);
                    break;
                case WIDE_BARTEXT:
                    tap_code16(KC_PIPE);
                    break;
                case WIDE_BBRTEXT:
                    if (is_mac_base()) {
                        symbol_key_mac("00a6","");
                    }
                    else if (user_config.is_linux_base) {
                        symbol_key_linux("00a6","");
                    }
                    else {
                        symbol_key("0166","", false);
                    }
                    break;
                default:
                    break;
                }
                register_mods(mods);   // reapply mods
                wide_firstchar = false;
            }

            // send keydown from the default layer
            register_code(keymap_key_to_keycode(biton32(default_layer_state), record->event.key));

            // if WIDE_TEXT_LAYER, add the extra spacing char
            if (layer == WIDE_TEXT_LAYR) {
                unregister_mods(mods); // temp remove mods
                switch (wide_text_mode) {
                case WIDE_STHRU:
                    tap_code16(KC_MINS);
                    break;
                case WIDE_UNDERLN:
                    tap_code16(KC_UNDS);
                    break;
                case WIDE_BARTEXT:
                    tap_code16(KC_PIPE);
                    break;
                case WIDE_BBRTEXT:
                    if (is_mac_base()) {
                        symbol_key_mac("00a6","");
                    }
                    else if (user_config.is_linux_base) {
                        symbol_key_linux("00a6","");
                    }
                    else {
                        symbol_key("0166","", false);
                    }
                    break;
                default:
                    tap_code16(KC_SPC);
                    break;
                }
                register_mods(mods);   // reapply mods
            }
        }
        else {
            unregister_code(keymap_key_to_keycode(biton32(default_layer_state), record->event.key));
        }
        return false;
        break;
    // tmux bound key list
    case TMUXLKEY:
        if (record->event.pressed) {
           //send_string(SS_LCTL("b") ":list-keys" SS_TAP(X_ENT));
           send_string(SS_LCTL("b") "?");
        }
        break;
    // tmux command list
    case TMUXLCMD:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("list-commands\n");
        }
        break;
    // tmux monitor window activity on 
    case TMONON:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("setw monitor-activity on\n");
        }
        break;
    // tmux monitor window activity off
    case TMONOF:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("setw monitor-activity off\n");
        }
        break;
    // tmux visual activity alerts on
    case TVISON:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("setw -g visual-activity on\n");
        }
        break;
    // tmux visual activity alerts off
    case TVISOF:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("setw -g visual-activity off\n");
        }
        break;
    // tmux move window left 1 position
    case TWINLFT:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("swap-window -t -1\n");
           send_string_with_delay(SS_LCTL("b") "p",10);
        }
        break;
    // tmux move window right 1 position
    case TWINRGT:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("swap-window -t +1\n");
           send_string_with_delay(SS_LCTL("b") "n",10);
        }
        break;
    case TJPANE:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("join-pane -t" SS_TAP(X_SPACE));
        }
        break;
    case WAVE:  // Types ~=~=~=~=~=~ or <~>~<~>~<~>~<~>
        static deferred_token wave_token = INVALID_DEFERRED_TOKEN;
        static uint8_t wave_phase = 0;
        if (!record->event.pressed) {  // On release.
            const uint8_t mods = get_mods();
            cancel_deferred_exec(wave_token);
            wave_token = INVALID_DEFERRED_TOKEN;
            // ensure the pattern always ends on a ">"
            if (mods & MOD_MASK_CTRL) {  // Is ctl held?
                unregister_mods(MOD_MASK_CTRL); // temp remove ctl
                if ((wave_phase & 1) == 0) {
                    send_string("<~>");
                }
                else {
                    tap_code16(KC_RABK);
                }
                register_mods(mods);           // restore mods
            }
            else {
                if ((wave_phase & 1) == 0) { tap_code16(KC_TILD); }
            }
            wave_phase = 0;
        }
        else if (!wave_token) {  // on press
            uint32_t wave_callback(uint32_t trigger_time, void* cb_arg) {
                const uint8_t mods = get_mods();
                const uint8_t oneshot_mods = get_oneshot_mods();
                if ((mods | oneshot_mods) & MOD_MASK_CTRL) {  // is ctl held?
                    del_oneshot_mods(MOD_MASK_CTRL); // remove ctl
                    unregister_mods(MOD_MASK_CTRL);  // remove ctl
                    tap_code16((++wave_phase & 1) ? KC_LABK : KC_RABK);
                    tap_code16(KC_TILD);
                    register_mods(mods);            // restore mods
                }
                else {
                    tap_code16((++wave_phase & 1) ? KC_TILD : KC_EQL);
                }
                return 16;  // call the callback every 16 ms
            }
            wave_token = defer_exec(1, wave_callback, NULL);
        }
        return false;
        break;
    case ARROW:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {  // is ctl held?
                // Temporarily delete cmd.
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                SEND_STRING("=>");
                register_mods(mods);            // restore mods
                return false;
            } else {
                SEND_STRING("->");
            }
        }
        break;

    case BSPCFAST:  // backspace with exponential repeating
        // initial delay before the first repeat
        static const uint8_t INIT_DELAY_MS = 250;
        // This array customizes the rate at which the Backspace key
        // repeats. The delay after the ith repeat is REP_DELAY_MS[i].
        // Values must be between 1 and 255.
        static const uint8_t REP_DELAY_MS[] PROGMEM = {
            99, 79, 65, 57, 49, 43, 40, 35, 33, 30, 28, 26, 25, 23, 22, 20,
            20, 19, 18, 17, 16, 15, 15, 14, 14, 13, 13, 12, 12, 11, 11, 10};
        static deferred_token bspc_token = INVALID_DEFERRED_TOKEN;
        static uint8_t rep_count = 0;
        if (!record->event.pressed) {  // Backspace released: stop repeating
            cancel_deferred_exec(bspc_token);
            bspc_token = INVALID_DEFERRED_TOKEN;
        }
        else if (!bspc_token) {  // Backspace pressed: start repeating
            tap_code(KC_BSPC);  // Initial tap of Backspace key
            rep_count = 0;
            uint32_t bspc_callback(uint32_t trigger_time, void* cb_arg) {
              tap_code(KC_BSPC);
              if (rep_count < sizeof(REP_DELAY_MS)) { ++rep_count; }
              return pgm_read_byte(REP_DELAY_MS - 1 + rep_count);
            }
            bspc_token = defer_exec(INIT_DELAY_MS, bspc_callback, NULL);
        }
        break;
    // get dynamic macros to work even with oneshot layers
    case DM_REC1:
    case DM_REC2:
    case DM_PLY1:
    case DM_PLY2:
        if (record->event.pressed) {
            if (oneshot_layer_active) {
                reset_oneshot_layer();
                osl_macro_token = defer_exec(100, osl_macro_callback, NULL);
            }
        }
        break;
    case DUAL_PLUSMIN:
        if (record->event.pressed) {
            // standard: plus symbol, while control is held: minus
            dual_key(KC_PPLS, KC_PMNS, MOD_MASK_CTRL);
        }
        break;
    case DUAL_MULTDIV:
        if (record->event.pressed) {
            // standard: asterisk, while control is held: divide
            dual_key(KC_PAST, KC_PSLS, MOD_MASK_CTRL);
        }
        break;
    case DUAL_ESC:
        if (record->event.pressed) {
           if (!macro_recording) {
               // send escapse
               register_code(KC_ESC);
           }
           else {
               // if macro is recording, stop it
               dynamic_macro_stop_recording();
           }
        }
        else {
            unregister_code(KC_ESC);
        }
        break;
    // this is setup so I can use key to insert a delay while recording a macro
    case DUAL_F12:
    case DUAL_F13:
        if (record->event.pressed) {
           if (!macro_recording && !is_macro_playing) { 
               // send F12 
               register_code(keycode == DUAL_F12 ? KC_F12 : KC_F13);
           }
           else {
               // if macro is recording or playing, insert a delay
               // wait_ms(150); // this only works when wired
               send_string(SS_DELAY(150)); // this works wired and wireless
           }
        }
        else {
           if (!macro_recording && !is_macro_playing) {
               unregister_code(keycode == DUAL_F12 ? KC_F12 : KC_F13);
           }
        }
        break; 
    case VI_REPLACE:
        if (record->event.pressed) {
           // start syntax for vi search and replace
           send_string(":%s///g" SS_TAP(X_LEFT) SS_TAP(X_LEFT) SS_TAP(X_LEFT));
        }
        break;
    case GIT_ADD:
        if (record->event.pressed) {
           // add updates to git commit
           send_string("git add -A" SS_TAP(X_ENT));
        }
        break;
    case GIT_COMMIT:
        if (record->event.pressed) {
           // commit changes
           send_string("git commit -m \"\"" SS_TAP(X_LEFT));
        }
        break;
    case GIT_PUSH:
        if (record->event.pressed) {
           // push commit to git repo
           send_string("git push" SS_TAP(X_ENT));
        }
        break;
    case GIT_CHKOUT:
        if (record->event.pressed) {
           // checkout last commit from git repo
           send_string("git checkout ." SS_TAP(X_ENT));
        }
        break;
    case GIT_LOG:
        if (record->event.pressed) {
           // show the git log
           send_string("git log" SS_TAP(X_ENT));
        }
        break;
    // volume up and down should be able to be pressed multiple times without cancelling a oneshot layer
    case KC_VOLD:
    case KC_VOLU:
        if (oneshot_layer_active || sim_osl) {
          reset_oneshot_layer();
          if (sim_osl_token) {
              cancel_deferred_exec(sim_osl_token);
              sim_osl_token = INVALID_DEFERRED_TOKEN;
          }
          if (record->event.pressed) {
              sim_osl = true;
              uint8_t layer = get_highest_layer(layer_state);
              layer_on(layer); // simulate that oneshot is still going
          }
          else {   // key release should use a delay for layer deactivation
              // this turns off the layer if further volume controls are not used within 500ms
              sim_osl_token = defer_exec(500, sim_osl_callback, NULL);
          }
        }
        break;
    case FJLIGHT:
    	if (record->event.pressed) {
	   // update the var used for f and j home key highlighting 
	   fj_light = !fj_light;
	}
    	break;
    case HROWLIGHT:
    	if (record->event.pressed) {
	   // update the var used for full home row keys highlighting 
	   hrow_light = !hrow_light;
	}
    	break;
    case KTRACK:
        if (record->event.pressed) {
           // update the var used to enable/disable keytracker and per-key fade
           enable_keytracker = !enable_keytracker;
        }
        break;
    case BASE_CHG:
        if (record->event.pressed) {
            int b_layer = is_mac_base() ? MAC_BASE_LAYR : BASE_LAYR;
            int b2_layer = is_mac_base() ? MAC_BASE2_LAYR : BASE2_LAYR;
            if (IS_LAYER_ON(b_layer))
            {
                set_single_persistent_default_layer(b2_layer);
                layer_move(b2_layer);
            }
            else
            {
                set_single_persistent_default_layer(b_layer);
                layer_move(b_layer);
            }
            base_layer_changed = true;
            return false;
        }
        break;
    case MK_HOLD:
    	if (record->event.pressed) {
            if (!ms_btn_held) {
                register_code(KC_MS_BTN1);
                ms_btn_held = true;
            }
            else {
                unregister_code(KC_MS_BTN1);
                ms_btn_held = false;
            }
        }
        break;
    case KC_MS_BTN1:
        ms_btn_held = record->event.pressed;
        break;
    case MK_ACCEL0:
        tap_code(record->event.pressed ? KC_MS_ACCEL0 : KC_MS_ACCEL1);
        break;
    case MK_ACCEL2:
        tap_code(record->event.pressed ? KC_MS_ACCEL2 : KC_MS_ACCEL1);
        break;
    case WM_SYM:
        if (record->event.pressed) {
            if (is_mac_base()) {
                register_code(KC_LOPT);
                layer_on(MAC_SYMBOL_LAYR);
            }
            else {
                layer_on(SYMBOL_LAYR);
            }
        }
        else {
            if (is_mac_base()) {
                if (!is_layer_locked(MAC_SYMBOL_LAYR)) {
                    unregister_code(KC_LOPT);
                    layer_off(MAC_SYMBOL_LAYR);
                }
            }
            else {
                if (!is_layer_locked(SYMBOL_LAYR)) { 
                    layer_off(SYMBOL_LAYR);
                }
            }
        } 
        break;
    case COLORTEST:
        if (record->event.pressed) {
            color_test_timer = timer_read();
            color_test = true;
        }
        break;
    // the following OPT keycodes mimic a macos option os layer for symbols and accents
    // symbol_key() is a fn to type a windows alt code on the numpad
    // symbol_key_linux() uses hex codes to type the same symbols on linux
    case OPT2:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2122","20ac");
            }
            else {
                symbol_key("0153","0128", false);
            }
        }   
        break;
    case OPT3:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00a3","2039");
            }
            else {
                symbol_key("156","0139", false);
            }
        }   
        break;
    case OPT4:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00a2","203a");
            }
            else {
                symbol_key("155","0155", false);
            }
        }   
        break;
    case OPT5:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("221e","fb01");
            }
            else {
                symbol_key("236","64257", false);
            }
        }   
        break;
    case OPT6:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00a7","fb02");
            }
            else {
                symbol_key("21","64258", false);
            }
        }   
        break;
    case OPT7:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00b6","2021");
            }
            else {
                symbol_key("20","0135", false);
            }
        }   
        break;
    case OPT8:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2022","00b0");
            }
            else {
                symbol_key("7","248", false);
            }
        }   
        break;
    case OPT9:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00aa","00b7");
            }
            else {
                symbol_key("166","9", false);
            }
        }   
        break;
    case OPT0:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00ba","201a");
            }
            else {
                symbol_key("167","0164", false);
            }
        }   
        break;
    case OPTMIN:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2013","2014");
            }
            else {
                symbol_key("0151","22", false);
            }
        }   
        break;
    case OPTEQ:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2260","00b1");
            }
            else {
                symbol_key("8800","241", false);
            }
        }   
        break;
    case OPTQ:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("0153","0152");
            }
            else {
                symbol_key("0156","0140", false);
            }
        }   
        break;
    case OPTW:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2211","201e");
            }
            else {
                symbol_key("228","0132", false);
            }
        }   
        break;
    case OPTR:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00ae","2030");
            }
            else {
                symbol_key("0174","0137", false);
            }
        }   
        break;
    case OPTT:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2020","02c7");
            }
            else {
                symbol_key("0134","259", false);
            }
        }   
        break;
    case OPTY:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00a5","00c1");
            }
            else {
                symbol_key("157","0193", false);
            }
        }   
        break;
    case OPTO:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00f8","00d8");
            }
            else {
                symbol_key("0248","0216", false);
            }
        }   
        break;
    case OPTP:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("03c0","03a0");
            }
            else {
                symbol_key("227","928", false);
            }
        }   
        break;
    case OPTLBR:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("201c","201d");
            }
            else {
                symbol_key("0147","0148", false);
            }
        }   
        break;
    case OPTRBR:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2018","2019");
            }
            else {
                symbol_key("0145","0146", false);
            }
        }   
        break;
    case OPTBSL:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00ab","00bb");
            }
            else {
                symbol_key("174","175", false);
            }
        }   
        break;
    case OPTA:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00e5","00c5");
            }
            else {
                symbol_key("0229","0197", false);
            }
        }   
        break;
    case OPTS:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00df","00cd");
            }
            else {
                symbol_key("225","0205", false);
            }
        }   
        break;
    case OPTD:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2202","00ce");
            }
            else {
                symbol_key("8706","0206", false);
            }
        }   
        break;
    case OPTF:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("0192","00cf");
            }
            else {
                symbol_key("159","0207", false);
            }
        }   
        break;
    case OPTG:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00a9","02dd");
            }
            else {
                symbol_key("0169","0180", false);
            }
        }   
        break;
    case OPTH:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("02d9","00d3");
            }
            else {
                symbol_key("0183","0211", false);
            }
        }
        break;
    case OPTJ:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2206","00d4");
            }
            else {
                symbol_key("30","0212", false);
            }
        }
        break;
    case OPTK:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("02da","03f0");
            }
            else {
                symbol_key("0186","0208", false);
            }
        }
        break;
    case OPTL:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00ac","00d2");
            }
            else {
                symbol_key("170","0210", false);
            }
        }
        break;
    case OPTSEM:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2026","00da");
            }
            else {
                symbol_key("0133","0218", false);
            }
        }
        break;
    case OPTAPO:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00e6","00c6");
            }
            else {
                symbol_key("0230","0198", false);
            }
        }
        break;
    case OPTZ:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("03a9","00b8");
            }
            else {
                symbol_key("234","0184", false);
            }
        }
        break;
    case OPTX:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2248","02db");
            }
            else {
                symbol_key("247","0215", false);
            }
        }
        break;
    case OPTC:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00e7","00c7");
            }
            else {
                symbol_key("0231","0199", false);
            }
        }
        break;
    case OPTV:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("221a","25ca");
            }
            else {
                symbol_key("251","4", false);
            }
        }
        break;
    case OPTB:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("222b","0131");
            }
            else {
                symbol_key("8747","0305", false);
            }
        }
        break;
    case OPTM:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("03bc","00c2");
            }
            else {
                symbol_key("230","0194", false);
            }
        }
        break;
    case OPTCOM:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2264","00af");
            }
            else {
                symbol_key("243","0175", false);
            }
        }
        break;
    case OPTDOT:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("2265","02d8");
            }
            else {
                symbol_key("242","0168", false);
            }
        }
        break;
    case OPTSLS:
        if (record->event.pressed) {
            if (user_config.is_linux_base) {
                symbol_key_linux("00f7","00bf");
            }
            else {
                symbol_key("0247","168", false);
            }
        }
        break;
    case SUITH:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("2665","2661");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("2665","2661");
            }
            else {
                symbol_key("3","3", false);
            }
        }
        break;
    case SUITD:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("2666","2662");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("2666","2662");
            }
            else {
                symbol_key("4","4", false);
            }
        }
        break;
    case SUITC:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("2663","2667");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("2663","2667");
            }
            else {
                symbol_key("5","5", false);
            }
        }
        break;
    case SUITS:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("2660","2664");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("2660","2664");
            }
            else {
                symbol_key("6","6", false);
            }
        }
        break;
    case SUP1:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("00b9","2074");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("00b9","2074");
            }
            else {
                symbol_key("0185","0185", false);
            }
        }
        break;
    case SUP2:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("00b2","2075");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("00b2","2075");
            }
            else {
                symbol_key("0178","0178", false);
            }
        }
        break;
    case SUP3:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("00b3","2076");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("00b3","2076");
            }
            else {
                symbol_key("0179","0179", false);
            }
        }
        break;
    case NBSP:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("00a0","00a6");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("00a0","00a6");
            }
            else {
                symbol_key("0160","0166", false);
            }
        }
        break;
    case CIRCL1:
        if (record->event.pressed) {
            // check mods first so can do a double-cirled number if alt is held
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                if (is_mac_base()) {
                    symbol_key_mac("24f5","24f5");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24f5","24f5");
                }
                else {
                    symbol_key("9461","9461", false);
                }
                register_mods(mods);
            } else {
                if (is_mac_base()) {
                    symbol_key_mac("2460","246a");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("2460","246a");
                }
                else {
                    symbol_key("9312","9322", false);
                }
            }
        }
        break;
    case CIRCL2:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                if (is_mac_base()) {
                    symbol_key_mac("24f6","24f6");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24f6","24f6");
                }
                else {
                    symbol_key("9462","9462", false);
                }
                register_mods(mods);
            } else {
                if (is_mac_base()) {
                    symbol_key_mac("2461","246b");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("2461","246b");
                }
                else {
                    symbol_key("9313","9323", false);
                }
            }
        }
        break;
    case CIRCL3:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                if (is_mac_base()) {
                    symbol_key_mac("24f7","24f7");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24f7","24f7");
                }
                else {
                    symbol_key("9463","9463", false);
                }
                register_mods(mods);
            } else {
                if (is_mac_base()) {
                    symbol_key_mac("2462","246c");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("2462","246c");
                }
                else {
                    symbol_key("9314","9324", false);
                }
            }
        }
        break;
    case CIRCL4:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                if (is_mac_base()) {
                    symbol_key_mac("24f8","24f8");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24f8","24f8");
                }
                else {
                    symbol_key("9464","9464", false);
                }
                register_mods(mods);
            } else {
                if (is_mac_base()) {
                    symbol_key_mac("2463","246d");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("2463","246d");
                }
                else {
                    symbol_key("9315","9325", false);
                }
            }
        }
        break;
    case CIRCL5:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                if (is_mac_base()) {
                    symbol_key_mac("24f9","24f9");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24f9","24f9");
                }
                else {
                    symbol_key("9465","9465", false);
                }
                register_mods(mods);
            } else {
                if (is_mac_base()) {
                    symbol_key_mac("2464","246e");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("2464","246e");
                }
                else {
                    symbol_key("9316","9326", false);
                }
            }
        }
        break;
    case CIRCL6:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                if (is_mac_base()) {
                    symbol_key_mac("24fa","24fa");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24fa","24fa");
                }
                else {
                    symbol_key("9466","9466", false);
                }
                register_mods(mods);
            } else {
                if (is_mac_base()) {
                    symbol_key_mac("2465","246f");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("2465","246f");
                }
                else {
                    symbol_key("9317","9327", false);
                }
            }
        }
        break;
    case CIRCL7:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                if (is_mac_base()) {
                    symbol_key_mac("24fb","24fb");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24fb","24fb");
                }
                else {
                    symbol_key("9467","9467", false);
                }
                register_mods(mods);
            } else {
                if (is_mac_base()) {
                    symbol_key_mac("2466","2470");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("2466","2470");
                }
                else {
                    symbol_key("9318","9328", false);
                }
            }
        }
        break;
    case CIRCL8:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                if (is_mac_base()) {
                    symbol_key_mac("24fc","24fc");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24fc","24fc");
                }
                else {
                    symbol_key("9468","9468", false);
                }
                register_mods(mods);
            } else {
                if (is_mac_base()) {
                    symbol_key_mac("2467","2471");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("2467","2471");
                }
                else {
                    symbol_key("9319","9329", false);
                }
            }
        }
        break;
    case CIRCL9:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                if (is_mac_base()) {
                    symbol_key_mac("24fd","24fd");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24fd","24fd");
                }
                else {
                    symbol_key("9469","9469", false);
                }
                register_mods(mods);
            } else {
                if (is_mac_base()) {
                    symbol_key_mac("2468","2472");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("2468","2472");
                }
                else {
                    symbol_key("9320","9330", false);
                }
            }   
        }
        break;
    case CIRCL0:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                if (is_mac_base()) { // this one can do both double circle 10 and a circle 20
                    symbol_key_mac("24fe","2473");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24fe","2473");
                }
                else {
                    symbol_key("9470","9331", false);
                }
                register_mods(mods);
            } else {
                if (is_mac_base()) {
                    symbol_key_mac("24ea","2469");
                }
                else if (user_config.is_linux_base) {
                    symbol_key_linux("24ea","2469");
                }
                else {
                    symbol_key("9450","9321", false);
                }
            }
        }
        break;
    case CIRCLQ:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24e0","24c6");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24e0","24c6");
            }
            else {
                symbol_key("9440","9414", false);
            }
        }
        break;
    case CIRCLW:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24e6","24cc");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24e6","24cc");
            }
            else {
                symbol_key("9446","9420", false);
            }
        }
        break;
    case CIRCLE:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24d4","24ba");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24d4","24ba");
            }
            else {
                symbol_key("9428","9402", false);
            }
        }
        break;
    case CIRCLR:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24e1","24c7");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24e1","24c7");
            }
            else {
                symbol_key("9441","9415", false);
            }
        }
        break;
    case CIRCLT:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24e3","24c9");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24e3","24c9");
            }
            else {
                symbol_key("9443","9417", false);
            }
        }
        break;
    case CIRCLY:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24e8","24ce");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24e8","24ce");
            }
            else {
                symbol_key("9448","9422", false);
            }
        }
        break;
    case CIRCLU:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24e4","24ca");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24e4","24ca");
            }
            else {
                symbol_key("9444","9418", false);
            }
        }
        break;
    case CIRCLI:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24d8","24be");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24d8","24be");
            }
            else {
                symbol_key("9432","9406", false);
            }
        }
        break;
    case CIRCLO:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24de","24c4");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24de","24c4");
            }
            else {
                symbol_key("9438","9412", false);
            }
        }
        break;
    case CIRCLP:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24df","24c5");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24df","24c5");
            }
            else {
                symbol_key("9439","9413", false);
            }
        }
        break;
    case CIRCLA:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24d0","24b6");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24d0","24b6");
            }
            else {
                symbol_key("9424","9398", false);
            }
        }
        break;
    case CIRCLS:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24e2","24c8");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24e2","24c8");
            }
            else {
                symbol_key("9442","9416", false);
            }
        }
        break;
    case CIRCLD:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24d3","24b9");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24d3","24b9");
            }
            else {
                symbol_key("9427","9401", false);
            }
        }
        break;
    case CIRCLF:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24d5","24bb");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24d5","24bb");
            }
            else {
                symbol_key("9429","9403", false);
            }
        }
        break;
    case CIRCLG:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24d6","24bc");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24d6","24bc");
            }
            else {
                symbol_key("9430","9404", false);
            }
        }
        break;
    case CIRCLH:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24d7","24bd");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24d7","24bd");
            }
            else {
                symbol_key("9431","9405", false);
            }
        }
        break;
    case CIRCLJ:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24d9","24bf");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24d9","24bf");
            }
            else {
                symbol_key("9433","9407", false);
            }
        }
        break;
    case CIRCLK:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24da","24c0");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24da","24c0");
            }
            else {
                symbol_key("9434","9408", false);
            }
        }
        break;
    case CIRCLL:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24db","24c1");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24db","24c1");
            }
            else {
                symbol_key("9435","9409", false);
            }
        }
        break;
    case CIRCLZ:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24e9","24cf");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24e9","24cf");
            }
            else {
                symbol_key("9449","9423", false);
            }
        }
        break;
    case CIRCLX:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24e7","24cd");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24e7","24cd");
            }
            else {
                symbol_key("9447","9421", false);
            }
        }
        break;
    case CIRCLC:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24d2","24b8");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24d2","24b8");
            }
            else {
                symbol_key("9426","9400", false);
            }
        }
        break;
    case CIRCLV:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24e5","24cb");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24e5","24cb");
            }
            else {
                symbol_key("9445","9419", false);
            }
        }
        break;
    case CIRCLB:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24d1","24b7");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24d1","24b7");
            }
            else {
                symbol_key("9425","9399", false);
            }
        }
        break;
    case CIRCLN:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24dd","24c3");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24dd","24c3");
            }
            else {
                symbol_key("9437","9411", false);
            }
        }
        break;
    case CIRCLM:
        if (record->event.pressed) {
            if (is_mac_base()) {
                symbol_key_mac("24dc","24c2");
            }
            else if (user_config.is_linux_base) {
                symbol_key_linux("24dc","24c2");
            }
            else {
                symbol_key("9436","9410", false);
            }
        }
        break;
    case KC_MYCM:
        if (is_mac_base() && record->event.pressed) {
            // open new Finder home dir
            tap_code16(LCMD(LSFT(KC_H)));
            return false;
        }
        break;
    case KC_CALC:
        if (is_mac_base() && record->event.pressed) {
            // send command + control + * then delay and then h (setup to open calculator pro)
            send_string(SS_LCTL(SS_LCMD(SS_TAP(X_PAST))) SS_DELAY(35) "h");
            return false;
        }
        break;
    case KC_APP:
        if (is_mac_base() && record->event.pressed) {
            tap_code(KC_LPAD);
            return false;
        }
        break;
    // set up so BASE_LAYR and MAC_BASE_LAYR has access to insert and delete
    case KC_HOME:
    case KC_END:
        if (IS_LAYER_ON(BASE_LAYR) || IS_LAYER_ON(MAC_BASE_LAYR)) {
            uint8_t layer = get_highest_layer(layer_state);
            if (layer == FN_LAYR) {
                if (record->event.pressed) {
                    register_code(keycode == KC_HOME ? KC_INS : KC_DEL);
                }
                else {
                    unregister_code(keycode == KC_HOME ? KC_INS : KC_DEL);
                }
                return false;
            }
        }
        break;
    case STHRU:
        if (record->event.pressed) {
            if (wide_text_mode == WIDE_STHRU) {
                wide_text_mode = WIDE_STANDARD;
                wide_firstchar = false;
            }
            else {
                wide_text_mode = WIDE_STHRU;
                wide_firstchar = true;
            }
        }
        break;
    case UNDERLN:
        if (record->event.pressed) {
            if (wide_text_mode == WIDE_UNDERLN) {
                wide_text_mode = WIDE_STANDARD;
                wide_firstchar = false;
            }
            else {
                wide_text_mode = WIDE_UNDERLN;
                wide_firstchar = true;
            }
        }
        break;
    case BARTEXT:
        if (record->event.pressed) {
            if (wide_text_mode == WIDE_BARTEXT) {
                wide_text_mode = WIDE_STANDARD;
                wide_firstchar = false;
            }
            else {
                wide_text_mode = WIDE_BARTEXT;
                wide_firstchar = true;
            }
        }
        break;
    case BBRTEXT:
        if (record->event.pressed) {
            if (wide_text_mode == WIDE_BBRTEXT) {
                wide_text_mode = WIDE_STANDARD;
                wide_firstchar = false;
            }
            else {
                wide_text_mode = WIDE_BBRTEXT;
                wide_firstchar = true;
            }
        }
        break;
    case FLASH_KB:
        if (record->event.pressed) {
           // command to flash this keyboard
           send_string("qmk flash -kb shortcut/bridge75 -km djcastaldo\n");
        }
        break;
    case BOOTLDR:
        if (record->event.pressed) {
            key_timer = timer_read32();
        } else if (timer_elapsed32(key_timer) >= 500) {
            reset_keyboard();
        }
        break;
    // these keycodes should start a timer to allow showing of indicators setup in bridge75.c
    case KC_USB:
    case KC_BT1:
    case KC_BT2:
    case KC_BT3:
    case KC_2G4:
    case KC_BATQ:
         if (record->event.pressed) {
            wls_action_timer = timer_read32();
         }
         break;
    }
    return process_record_secrets(keycode, record);
}

void dual_key(uint16_t std_keycode, uint16_t alt_keycode, uint8_t mod_mask) {
    // if mod is being held, send mod_keycode
    // get current mod states
    const uint8_t mods = get_mods();
    if (mods & mod_mask) {
        unregister_mods(mod_mask);  // remove mod
        tap_code16(alt_keycode);
        register_mods(mods); // restore original mods
    }
    // otherwise send std_keycode
    else {
        tap_code16(std_keycode);
    }
}

void symbol_key(const char *alt_code, const char *shift_alt_code, bool is_tap_dance) {
    // get current mod and one-shot mod states.
    const uint8_t mods = get_mods();
    const uint8_t oneshot_mods = get_oneshot_mods();
    bool numlockChanged; // this numlock stuff lets this work in all scenarios
    numlockChanged = false;
    if ((mods | oneshot_mods) & MOD_MASK_SHIFT) { // if shift is being held
        if (shift_alt_code == NULL || *shift_alt_code == '\0') { // null or empty string
            return;
        }
        if (is_tap_dance) {
            // this is needed because tap dances don't correctly unregister shift
            if (host_keyboard_led_state().num_lock) {
                 tap_code(KC_NUM);
                 numlockChanged = true;
            }
            dprintf("alt hold\n");
            register_code(KC_LALT); // hold down alt
            type_numpad_keys_from_string(shift_alt_code); // send to fn to type numpad keys
            dprintf("alt release\n");
            unregister_code(KC_LALT); // release alt
        }
        else {
            if (!host_keyboard_led_state().num_lock) {
                 tap_code(KC_NUM);
                 numlockChanged = true;
            }
            del_oneshot_mods(MOD_MASK_SHIFT); // delete oneshot shift mod
            unregister_mods(MOD_MASK_SHIFT);  // temporarily delete shift mod
            register_code(KC_LALT); // hold down alt
            type_numpad_keys_from_string(shift_alt_code); // send to fn to type numpad keys
            unregister_code(KC_LALT); // release alt
            register_mods(mods);
        }
    } else {
        if (alt_code == NULL || *alt_code == '\0') { // null or empty string
            return;
        }
        if (!host_keyboard_led_state().num_lock) {
             tap_code(KC_NUM);
             numlockChanged = true;
        }
        dprintf("alt hold\n");
        register_code(KC_LALT); // hold down alt
        type_numpad_keys_from_string(alt_code); // send to fn to type numpad keys
        dprintf("alt release\n");
        unregister_code(KC_LALT); // release alt
    }
    if (numlockChanged) {
        tap_code(KC_NUM);
    }
}

void symbol_key_linux(const char *hex_code, const char *shift_hex_code) {
    // get current mod and one-shot mod states.
    const uint8_t mods = get_mods();
    const uint8_t oneshot_mods = get_oneshot_mods();
    const char *ucode = ((mods | oneshot_mods) & MOD_MASK_SHIFT) ? shift_hex_code : hex_code;
    if (ucode == NULL || *ucode == '\0') { // null or empty string
        return;
    }
    clear_oneshot_mods();
    unregister_mods(mods); // temp remove mods
    tap_code16(C(S(KC_U))); // start the unicode sequence
    // type the hex chars
    send_string_with_delay(ucode,5);
    // finish sequence
    tap_code(KC_SPC);
    register_mods(mods); // add back mods
}

void symbol_key_mac(const char *unicode, const char *shift_unicode) {
    // get current mod and one-shot mod states.
    const uint8_t mods = get_mods();
    const uint8_t oneshot_mods = get_oneshot_mods();
    if ((mods | oneshot_mods) & MOD_MASK_SHIFT) { // if shift is being held
        del_oneshot_mods(MOD_MASK_SHIFT); // delete oneshot shift mod
        unregister_mods(MOD_MASK_SHIFT);  // temporarily delete shift mod
        send_string(SS_LCTL(SS_LOPT(SS_LCMD(SS_TAP(X_SPC))))); // switch os keybaord input to unicode
        add_mods(MOD_MASK_ALT); // hold down option
        send_string(shift_unicode); // send shift_unicode
        del_mods(MOD_MASK_ALT); // release option
        send_string_with_delay(SS_LCTL(SS_LOPT(SS_LCMD(SS_LSFT(SS_TAP(X_SPC))))),10); // switch os keyboard input back to language
        register_mods(mods); // restore original mods
    } else {
        send_string(SS_LCTL(SS_LOPT(SS_LCMD(SS_TAP(X_SPC))))); // switch os keybaord input to unicode
        add_mods(MOD_MASK_ALT); // hold down option
        send_string(unicode); // send unicode
        del_mods(MOD_MASK_ALT); // release option
        send_string_with_delay(SS_LCTL(SS_LOPT(SS_LCMD(SS_LSFT(SS_TAP(X_SPC))))),10); // switch os keyboard input back to language
    }
}

// send_string doesn't use the numpad, so this fn was created to type numbers using the numpad
void type_numpad_keys_from_string(const char *stringnum) {
    // now need to loop through each char in the char pointer until a null terminator
    const char *ptr = stringnum;
    while (*ptr != '\0') {
        switch (*ptr) {
        case '0':
            dprintf("0 tap\n");
            tap_code(KC_P0);
            break;
        case '1':
            dprintf("1 tap\n");
            tap_code(KC_P1);
            break;
        case '2':
            dprintf("2 tap\n");
            tap_code(KC_P2);
            break;
        case '3':
            dprintf("3 tap\n");
            tap_code(KC_P3);
            break;
        case '4':
            dprintf("4 tap\n");
            tap_code(KC_P4);
            break;
        case '5':
            dprintf("5 tap\n");
            tap_code(KC_P5);
            break;
        case '6':
            dprintf("6 tap\n");
            tap_code(KC_P6);
            break;
        case '7':
            dprintf("7 tap\n");
            tap_code(KC_P7);
            break;
        case '8':
            dprintf("8 tap\n");
            tap_code(KC_P8);
            break;
        case '9':
            dprintf("9 tap\n");
            tap_code(KC_P9);
            break;
        default:
            dprintf("no number\n");
            break;
        }
    ptr++;
    }   
}

bool rgb_matrix_indicators_advanced_user(uint8_t led_min, uint8_t led_max) {
    uint8_t layer = get_highest_layer(layer_state);
    // color an indicator 
    switch (layer) {
    case FN_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_GREEN);
        break;
    case SFT_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_ORANGE);
        break;
    case CTL_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_RED);
        break;
    case TMUX_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_CYAN);
        break;
    case SYMBOL_LAYR:
    case MAC_SYMBOL_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_BLUE);
        break;
    case WIDE_TEXT_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_PURPLE);
        break;
    case CIRCLE_TEXT_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_CORAL);
        break;
    case LOCK_LAYR:
        break;
    default:
        break;
    }
    if (layer > 3) {
        for (uint8_t row = 0; row < MATRIX_ROWS; ++row) {
            for (uint8_t col = 0; col < MATRIX_COLS; ++col) {
                uint8_t index = g_led_config.matrix_co[row][col];
    
                if (index >= led_min && index < led_max && index != NO_LED &&
                keymap_key_to_keycode(layer, (keypos_t){col,row}) > KC_TRNS) {
                    switch (layer) {
                    case FN_LAYR:
                        if (index == I_MREC1 || index == I_MREC2) { // macro recording keys
                            rgb_matrix_set_color(index, RGB_MAGENTA);
                        }
                        else {
                            rgb_matrix_set_color(index, RGB_GREEN);
                        }
                        break;
                    case SFT_LAYR:
                        rgb_matrix_set_color(index, RGB_ORANGE);
                        break;
                    case CTL_LAYR:
                        rgb_matrix_set_color(index, RGB_RED);
                        break;
                    case TMUX_LAYR:
                        rgb_matrix_set_color(index, RGB_CYAN);
                        break;
                    case SYMBOL_LAYR:
                    case MAC_SYMBOL_LAYR:
                        rgb_matrix_set_color(index, RGB_BLUE);
                        break;
                    case WIDE_TEXT_LAYR:
                        rgb_matrix_set_color(index, RGB_PURPLE);
                        break;
                    case CIRCLE_TEXT_LAYR:
                        rgb_matrix_set_color(index, RGB_CORAL);
                        break;
                    case LOCK_LAYR:
                        break;
                    default:
                        rgb_matrix_set_color(index, 0x77, 0x77, 0x77);
                        break;
                    }
                }
            }
        }
// ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
        // custom colors for layer keys on fn layer
        if (layer == FN_LAYR) {
          rgb_matrix_set_color(I_LSFT, RGB_ORANGE); // left shift
          rgb_matrix_set_color(I_RSFT, RGB_ORANGE); // right shift
          rgb_matrix_set_color(I_LALT, RGB_RED);    // left alt / left cmd
          rgb_matrix_set_color(I_RALT, RGB_RED);    // right alt / right cmd 
          rgb_matrix_set_color(I_TAB, RGB_CYAN);    // tab
          rgb_matrix_set_color(I_LGUI, RGB_BLUE);   // left win / left opt 
        }
// ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~ 
        // custom colors for tap dance keys on symbol layer
        else if (layer == SYMBOL_LAYR || layer == MAC_SYMBOL_LAYR) {
          rgb_matrix_set_color(I_GRV, RGB_YELLOW); // grave
          rgb_matrix_set_color(I_1, RGB_YELLOW);   // 1
          rgb_matrix_set_color(I_E, RGB_YELLOW);   // e
          rgb_matrix_set_color(I_U, RGB_YELLOW);   // u
          rgb_matrix_set_color(I_I, RGB_YELLOW);   // i
          rgb_matrix_set_color(I_N, RGB_YELLOW);   // n
        }
// ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
        // set up the layer key blinking indicator
        if (!layer_timer) {
            is_led_on = true;
            layer_timer = timer_read();
        }
        // toggle an led light every 500 ms while the layer is active
        else if (timer_elapsed(layer_timer) > 500)
        {
            is_led_on = !is_led_on;
            layer_timer = timer_read();
        }
        // the led and color to flash on each layer to show the layer is active
        if (is_led_on)
        {
            switch (layer) {
            case FN_LAYR:
                rgb_matrix_set_color(I_CAPS, RGB_GREEN);  // caps
                rgb_matrix_set_color(I_FN, RGB_GREEN);    // fn
                break;
            case SFT_LAYR:
                rgb_matrix_set_color(I_LSFT, RGB_ORANGE); // lshift
                rgb_matrix_set_color(I_RSFT, RGB_ORANGE); // rshift
                break;
            case CTL_LAYR:
                rgb_matrix_set_color(I_LALT, RGB_RED);    // lalt
                rgb_matrix_set_color(I_RALT, RGB_RED);    // ralt
                break;
            case TMUX_LAYR:
                rgb_matrix_set_color(I_TAB, RGB_CYAN);    // tab
                break;
            case SYMBOL_LAYR:
                if (timer_elapsed(layer_timer) > 250) {
                    rgb_matrix_set_color(I_RALT, RGB_YELLOW); // ralt
                    rgb_matrix_set_color(I_LGUI, RGB_YELLOW); // lgui
                }
                else {
                    rgb_matrix_set_color(I_RALT, RGB_BLUE);   // ralt
                    rgb_matrix_set_color(I_LGUI, RGB_BLUE);   // lgui
                }
                break;
            case MAC_SYMBOL_LAYR:
                if (timer_elapsed(layer_timer) > 250) {
                    rgb_matrix_set_color(I_LOPT, RGB_YELLOW); // lopt
                    rgb_matrix_set_color(I_RCMD, RGB_YELLOW); // rcmd
                }
                else {
                    rgb_matrix_set_color(I_LOPT, RGB_BLUE);   // lopt
                    rgb_matrix_set_color(I_RCMD, RGB_BLUE);   // rcmd
                }
                break;
            case WIDE_TEXT_LAYR:
                rgb_matrix_set_color(I_RSFT, RGB_PURPLE);     // rshift
                break;
            case CIRCLE_TEXT_LAYR:
                rgb_matrix_set_color(I_RSFT, RGB_CORAL);      // rshift
                break;
            }
        }
        // blink the indicator to show layer lock in on
        if (is_layer_locked(layer)) {
            if (!layer_lock_timer || timer_elapsed(layer_lock_timer) > 1000) {
                is_layer_lock_led_on = !is_layer_lock_led_on;
                layer_lock_timer = timer_read();
            }
            if (is_layer_lock_led_on) {
                rgb_matrix_set_color(I_LLOCK, RGB_WHITE); // just make it white
            }
            else if ((timer_elapsed(layer_lock_timer) > 200 && timer_elapsed(layer_lock_timer) < 400) || 
                     (timer_elapsed(layer_lock_timer) > 600)) {
                rgb_matrix_set_color(I_LLOCK, RGB_WHITE); // white alternate with layer color
            }
        }
    }
    else {
        rgb_matrix_set_color(I_FN, RGB_BLUE);        // fn
        rgb_matrix_set_color(I_TAB, 0x77,0x77,0x77); // tab
        // on windows or linux, highlight some possible winkey/super shortcuts while winkey/super is held
        if (is_winkey_held) {
            if (user_config.is_linux_base) {
                for (int i = 0; i < super_scut_keys_size; i++) {
                    rgb_matrix_set_color(super_scut_keys[i], 102, 178, 255);   // gnome super shortcut keys
                }
                for (int i = 0; i < super_scut_altcolor_size; i++) {
                    rgb_matrix_set_color(super_scut_altcolor[i], RGB_BLUE);    // gnome super shortcut keys
                }
            }
            else {
                for (int i = 0; i < winkey_scut_keys_size; i++) {
                    rgb_matrix_set_color(winkey_scut_keys[i], 102, 178, 255);  // winkey shortcut keys
                }
                for (int i = 0; i < winkey_scut_altcolor_size; i++) {
                    rgb_matrix_set_color(winkey_scut_altcolor[i], RGB_BLUE);   // winkey shortcut keys
                }
            }
        }    
        if (!host_keyboard_led_state().caps_lock) {
          rgb_matrix_set_color(I_CAPS, RGB_BLUE);    // caps
        }
        // if caps lock, color caps alpha keys
        else {
           for (uint8_t i = led_min; i < led_max; i++) {
             if (is_capslock_shifted(i)) {
                rgb_matrix_set_color(i, RGB_RED);
             }
           }
        }
        // color caps word too
        if (is_caps_word_on())
        {
          // set capitilized keys red when caps word is active
          for (uint8_t i = led_min; i < led_max; i++) {
            if (is_capsword_shifted(i)) {
               rgb_matrix_set_color(i, RGB_RED);
            }
          }
          rgb_matrix_set_color(I_LSFT, 0x77, 0x77, 0x77); // turn left shift white when caps_word is active
          rgb_matrix_set_color(I_RSFT, 0x77, 0x77, 0x77); // turn right shift white when caps_word is active
        }
        // if not caps word, nor caps lock, then do the hrow colors if hrow_light setting is turned on       
        else if (!host_keyboard_led_state().caps_lock) { 
          if (hrow_light) {
              rgb_matrix_set_color(I_A, RGB_GREEN);    // a
              rgb_matrix_set_color(I_S, RGB_GREEN);    // s
              rgb_matrix_set_color(I_D, RGB_GREEN);    // d
              rgb_matrix_set_color(I_F, RGB_GREEN);    // f
              rgb_matrix_set_color(I_J, RGB_GREEN);    // j
              rgb_matrix_set_color(I_K, RGB_GREEN);    // k
              rgb_matrix_set_color(I_L, RGB_GREEN);    // l
              rgb_matrix_set_color(I_SEMI, RGB_GREEN); // ;
          }
          if (fj_light) {
              rgb_matrix_set_color(I_F, 0x77, 0x77, 0x77); // f
              rgb_matrix_set_color(I_J, 0x77, 0x77, 0x77); // j
          }
        }
    }
    // if key lock is watching for next key, flash the indicator yellow and orange
    if (is_key_lock_watching()) {
        if (!key_lock_timer || timer_elapsed(key_lock_timer) > 500) {
            is_key_lock_led_on = !is_key_lock_led_on;;
            key_lock_timer = timer_read();
        }
        if (is_key_lock_led_on) {
            rgb_matrix_set_color(I_INDICATOR, RGB_YELLOW);  // indicator 
        }
        else {
            rgb_matrix_set_color(I_INDICATOR, RGB_ORANGE);  // indicator 
        }
    }
    // if key lock is activated, flash the indicator white and red
    else if (is_key_locked) {
        if (!key_lock_timer || timer_elapsed(key_lock_timer) > 500) {
            is_key_lock_led_on = !is_key_lock_led_on;;
            key_lock_timer = timer_read();
        }
        if (is_key_lock_led_on) {
            rgb_matrix_set_color(I_INDICATOR, RGB_WHITE); // indicator
        }
        else {
            rgb_matrix_set_color(I_INDICATOR, RGB_RED);   // indicator
        }
        // and light up normal modifiers if they are currently locked
        if (lctl_locked) {
            rgb_matrix_set_color(I_LCTL, RGB_WHITE);      // lctl
        }
        if (lalt_locked) {
            if (is_mac_base()) {
                rgb_matrix_set_color(I_LOPT, RGB_WHITE);  // lopt
            }
            else {
                rgb_matrix_set_color(I_LALT, RGB_WHITE);  // lalt
            }
        }
        if (lsft_locked) {
            rgb_matrix_set_color(I_LSFT, RGB_WHITE);      // lsft
        }
        if (lgui_locked) {
            if (is_mac_base()) {
                rgb_matrix_set_color(I_LCMD, RGB_WHITE);  // lcmd
            }
            else {
                rgb_matrix_set_color(I_LGUI, RGB_WHITE);  // lgui
            }
        }
        if (rsft_locked) {
            rgb_matrix_set_color(I_RSFT, RGB_WHITE);      // rsft
        }
        if (ralt_locked) {
            rgb_matrix_set_color(I_RALT, RGB_WHITE);      // ralt
        }
    }

    // check if a base layer change happened, and flash some indicators to show a change occured
    if (base_layer_changed) {
        if (!base_change_timer || timer_elapsed(base_change_timer) > 1300) {
            base_change_timer = timer_read();
        } 
        rgb_matrix_set_color(I_INSHOME, RGB_WHITE);             // home/insert
        if (timer_elapsed(base_change_timer) > 300) {
            rgb_matrix_set_color(I_DELPGUP, RGB_WHITE);         // pgup/del
        }
        if (timer_elapsed(base_change_timer) > 600) {
            rgb_matrix_set_color(I_PGUPPGDN, RGB_WHITE);        // pgdn/pgup 
        }
        if (timer_elapsed(base_change_timer) > 900) {
            rgb_matrix_set_color(I_PGDNEND, RGB_WHITE);         // end/pgdn
        }
        if (timer_elapsed(base_change_timer) > 1200) {
            base_layer_changed = false;
        }
    }    
    // check if os change happened, and flash some indicators to show the change
    if (os_changed) {
        // turn off all currently lit leds first
        for (uint8_t i = led_min; i < led_max; i++) {
            rgb_matrix_set_color(i, 0x00, 0x00, 0x00);
        }
        int os_key1 = is_mac_base() ? I_M : I_W;
        int os_key2 = is_mac_base() ? I_A : I_I;
        int os_key3 = is_mac_base() ? I_C : I_N;
        if (!is_mac_base() && user_config.is_linux_base) {
            os_key1 = I_L;
        }
        if (!os_change_timer || timer_elapsed(os_change_timer) > 1900) {
            os_change_timer = timer_read();
        } 
        rgb_matrix_set_color(os_key1, RGB_WHITE);           // M | W | L
        if (timer_elapsed(os_change_timer) > 300) {
            rgb_matrix_set_color(os_key2, RGB_WHITE);       // A | I | I
        }
        if (timer_elapsed(os_change_timer) > 600) {
            rgb_matrix_set_color(os_key3, RGB_WHITE);       // C | N | N
        }
        if (timer_elapsed(os_change_timer) > 1800) {
            os_changed = false;
        }
    }

    if (is_in_leader_sequence) {
        if (!leader_timer || timer_elapsed(leader_timer) > 500) {
            is_leader_led_on = !is_leader_led_on;
            leader_timer = timer_read();
        }
        if (is_leader_led_on) {
            rgb_matrix_set_color(I_INDICATOR, RGB_TURQUOISE); // indicator 
            rgb_matrix_set_color(I_L, RGB_TURQUOISE);         // l
        }
        else {
            rgb_matrix_set_color(I_INDICATOR, RGB_CYAN);
            rgb_matrix_set_color(I_L, RGB_CYAN);
        }
    }
    // if a leader sequence error occured, blink all leds red
    else if (is_leader_error) {
        if (!leader_error_timer || timer_elapsed(leader_error_timer) > 250) {
            is_leader_error_led_on = !is_leader_error_led_on;
            leader_error_timer = timer_read();
        }
        if (is_leader_error_led_on) {
            for (uint8_t i = led_min; i < led_max; i++) {
                rgb_matrix_set_color(i, RGB_RED);
            }
        }
    }

    // if any rgb key highlights are on, turn the setting keys white on layer CTL_LAYR
    if (layer == CTL_LAYR)
    {
        if (fj_light) {
            rgb_matrix_set_color(I_FJLIGHT, RGB_WHITE);     // fj highlight key
        }
        if (hrow_light) {
            rgb_matrix_set_color(I_HROWLIGHT, RGB_WHITE);   // hrow highlight key
        }
        if (enable_keytracker) {
            rgb_matrix_set_color(I_KTRACK, RGB_WHITE);      // keytracker set key
        }
    }

    // calculate the reactive rgb for keypresses
    if (enable_keytracker) {
        for (int i = 0; i < tk_length; i++) {
            if (tracked_keys[i].press) {
                rgb_matrix_set_color(tracked_keys[i].index, 255, 255, 255);
            }
            // do the key fade if key should fade
            // this is a modified fade to get a smoother look and be mostly white but a bit blue
            else if (key_should_fade(tracked_keys[i], layer)) {
                if (tracked_keys[i].fade > 255) {
                    rgb_matrix_set_color(tracked_keys[i].index, 255, 255, 255);
                } 
                else if (tracked_keys[i].fade > 230) {
                    rgb_matrix_set_color(tracked_keys[i].index, tracked_keys[i].fade, tracked_keys[i].fade, 255);
                } else {
                    rgb_matrix_set_color(tracked_keys[i].index, tracked_keys[i].fade, tracked_keys[i].fade, tracked_keys[i].fade + 25);
                }  
            }
        }
    }
    if (macro_recording) {
        // flash the indicator if macro is recording
        if (timer_elapsed(macro_timer) > 250) {
            is_macro_led_on = !is_macro_led_on;;
            macro_timer = timer_read();
        }
        if (is_macro_led_on) {
            rgb_matrix_set_color(I_INDICATOR, RGB_RED);   // indicator 
            if (macro_direction == 1) {
                rgb_matrix_set_color(I_MREC1, RGB_RED);   // [ macro1 record key
            }
            else {
                rgb_matrix_set_color(I_MREC2, RGB_RED);   // ] macro2 record key
            }
        }
        else {
            rgb_matrix_set_color(I_INDICATOR, 0, 0, 0);   // indicator 
            if (macro_direction == 1) {
                rgb_matrix_set_color(I_MREC1, 0, 0, 0);   // [ macro1 record key
            }
            else {
                rgb_matrix_set_color(I_MREC2, 0, 0, 0);   // ] macro2 record key
            }
        }
    }
    // if this is a color test, then light keys in each qmk named color
    if (color_test) {
        // turn off the color test if it has been going for 15 seconds
        if (timer_elapsed(color_test_timer) > 15000) {
            color_test = false;
        }
        else { // show the named colors defined in color.h, https://docs.qmk.fm/features/rgb_matrix
            rgb_matrix_set_color(I_Q, RGB_AZURE);
            rgb_matrix_set_color(I_W, RGB_BLACK);
            rgb_matrix_set_color(I_E, RGB_BLUE);
            rgb_matrix_set_color(I_R, RGB_CHARTREUSE);
            rgb_matrix_set_color(I_T, RGB_CORAL);
            rgb_matrix_set_color(I_Y, RGB_CYAN);
            rgb_matrix_set_color(I_U, RGB_GOLD);
            rgb_matrix_set_color(I_I, RGB_GOLDENROD);
            rgb_matrix_set_color(I_O, RGB_GREEN);
            rgb_matrix_set_color(I_P, RGB_MAGENTA);
            rgb_matrix_set_color(I_A, RGB_ORANGE);
            rgb_matrix_set_color(I_S, RGB_PINK);
            rgb_matrix_set_color(I_D, RGB_PURPLE);
            rgb_matrix_set_color(I_F, RGB_RED);
            rgb_matrix_set_color(I_G, RGB_SPRINGGREEN);
            rgb_matrix_set_color(I_H, RGB_TEAL);
            rgb_matrix_set_color(I_J, RGB_TURQUOISE);
            rgb_matrix_set_color(I_K, RGB_WHITE);
            rgb_matrix_set_color(I_L, RGB_YELLOW);
        }
    }
    // track if this is the middle of an accent key tap dance and illuminate the appropriate accent char
    if (act_char_led_index > 0) {
        rgb_matrix_set_color(act_char_led_index, RGB_WHITE);  // accent char led 
    } 
    // track if mouse button is held on SFT_LAYR
    if (layer == SFT_LAYR && ms_btn_held) {
        rgb_matrix_set_color(I_PGUPPGDN, RGB_WHITE); // mouse btn1 hold key
    }
    // track mode keys on WIDE_TEXT_LAYR
    if (layer == WIDE_TEXT_LAYR) {
        switch (wide_text_mode) {
        case WIDE_STHRU:
            rgb_matrix_set_color(I_STHRU, RGB_WHITE);    // sthru toggle
            break;
        case WIDE_UNDERLN:
            rgb_matrix_set_color(I_UNDERLN, RGB_WHITE);  // underln toggle
            break;
        case WIDE_BARTEXT:
            rgb_matrix_set_color(I_BARTEXT, RGB_WHITE);  // bartext toggle
            break;
        case WIDE_BBRTEXT:
            rgb_matrix_set_color(I_BBRTEXT, RGB_WHITE);  // bbrtext toggle
            break;
        default:
            break;
        }
    }
    // track caps_lock
    if (host_keyboard_led_state().caps_lock) {
        rgb_matrix_set_color(I_CAPS, RGB_WHITE);  // caps
    }
    // track num_lock
    if (layer == SFT_LAYR && host_keyboard_led_state().num_lock) {
        rgb_matrix_set_color(I_NUMLOCK, RGB_WHITE);
    }
    // track scroll_lock
    if (layer == FN_LAYR && host_keyboard_led_state().scroll_lock) {
        rgb_matrix_set_color(I_SLOCK, RGB_WHITE);
    }
        

// wireless connection indicators, setup in bridge75.c 
#    ifdef WIRELESS_ENABLE
    // CTL_LAYR will alwys show connection indicator; other layers for 4 seconds after wireless/battery keycode is used 
    if (layer == CTL_LAYR || (wls_action_timer && timer_elapsed32(wls_action_timer) < 4000)) {
        return true;
    }
#    endif
    return false;
}

// a function to check for if a key press should fade the rgb
bool key_should_fade(keytracker key, uint8_t layer) {
    bool should_fade = true;
    if ((key.fade < 1) ||
      ((layer == FN_LAYR || layer == SFT_LAYR || layer == WIDE_TEXT_LAYR ||
        layer == CIRCLE_TEXT_LAYR || is_caps_word_on()) &&
        (key.index == I_LSFT || key.index == I_RSFT)) ||                                                         // l/r shift
      ((layer == FN_LAYR || layer == CTL_LAYR) && (key.index == I_LALT || key.index == I_RALT)) ||               // l/r alt
      (macro_recording && (key.index == I_MREC1 || key.index == I_MREC2)) ||                                     // macro recording keys
      (is_layer_locked(layer) && key.index == I_LLOCK) ||                                                        // layer lock key
      (is_in_leader_sequence && key.index == I_L) ||                                                             // leader key
      (layer == SFT_LAYR && (key.index == I_NUMLOCK || key.index == I_PGUPPGDN)) ||                              // num lock, mouse hold
      (layer == FN_LAYR && key.index == I_SLOCK) ||                                                              // scroll lock
      (layer == WIDE_TEXT_LAYR && (key.index == I_BARTEXT || key.index == I_STHRU ||
         key.index == I_UNDERLN || key.index == I_BBRTEXT)) ||                                                   // wide-text toggles
      (layer == CTL_LAYR && (key.index == I_FJLIGHT || key.index == I_HROWLIGHT)) ||                             // hrow/fj indicators 
      (os_changed) ||                                                                                            // mac/win/lin change
      (layer == SYMBOL_LAYR && (key.index == I_GRV || key.index == I_1 || key.index == I_E ||
                                key.index == I_I || key.index == I_U || key.index == I_N ||                      // accent keys
                                key.index == I_RALT || key.index == I_LGUI)) ||                                  // sym_layr ralt, lgui
      (key.index == I_CAPS) || (key.index == I_FN || key.index == I_TAB)) {                                      // caps lock, fn, tab
        should_fade = false;
    }
    return should_fade;
}

// determine the current tap dance state
int cur_dance (tap_dance_state_t *state) {
  if (state->count == 1) {
    if (!state->pressed) {
        return SINGLE_TAP;
    } else {
        return SINGLE_HOLD;
    }
  } else if (state->count == 2) {
    if (!state->pressed) {
        return DOUBLE_TAP;
    } else {
        return DOUBLE_HOLD;
    }
  } else if (state->count == 3) {
    return TRIPLE_TAP;
  } else if (state->count == 4) {
    return QUAD_TAP;
  } else if (state->count == 5) {
    return PENT_TAP;
  } else if (state->count == 6) {
    return HEXA_TAP;
  }
  else return 9;
}

// initialize tap structure associated with each tap dance key
static tap caps_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap ralt_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap fn_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap rsft_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap kbunlock_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap actgrv_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap act1_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap acte_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap actu_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap acti_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap actn_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap lgui_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap rcmd_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap lopt_tap_state = {
  .is_press_action = true,
  .state = 0
};

// caps tap dance key function
void caps_finished (tap_dance_state_t *state, void *user_data) {
  caps_tap_state.state = cur_dance(state);
  switch (caps_tap_state.state) {
    case SINGLE_TAP:
      tap_code(KC_CAPS);
      break;
    case SINGLE_HOLD:
      layer_on(FN_LAYR);
      break;
    case DOUBLE_TAP:
      if (layer_state_is(FN_LAYR)) {
        //if already set, then switch it off
        layer_lock_off(FN_LAYR);
      } else {
        //if not already set, then switch the layer on
        layer_lock_on(FN_LAYR);
      }
      break;
    case TRIPLE_TAP:
      if (layer_state_is(SFT_LAYR)) {
        //if already set, then switch it off
        layer_lock_off(SFT_LAYR);
      } else {
        //if not already set, then switch the layer on
        layer_lock_on(SFT_LAYR);
      }
      break;
    case QUAD_TAP:
      if (layer_state_is(CTL_LAYR)) {
        //if already set, then switch it off
        layer_lock_off(CTL_LAYR);
      } else {
        //if not already set, then switch the layer on
        layer_lock_on(CTL_LAYR);
      }
      break;
    case PENT_TAP:
      if (layer_state_is(TMUX_LAYR)) {
        //if already set, then switch it off
        layer_lock_off(TMUX_LAYR);
      } else {
        //if not already set, then switch the layer on
        layer_lock_on(TMUX_LAYR);
      }
      break;
    case HEXA_TAP:
      if (!is_mac_base()) {
          if (layer_state_is(SYMBOL_LAYR)) {
            //if already set, then switch it off
            layer_lock_off(SYMBOL_LAYR);
          } else {
            //if not already set, then switch the layer on
            layer_lock_on(SYMBOL_LAYR);
          }
      }
      break;
  }
}
void caps_reset (tap_dance_state_t *state, void *user_data) {
  //if the key was held down and now is released then switch off the layer
  if (caps_tap_state.state==SINGLE_HOLD && !is_layer_locked(FN_LAYR)) {
    layer_off(FN_LAYR);
  }
  caps_tap_state.state = 0;
}

// function for ralt tap dance
void ralt_finished (tap_dance_state_t *state, void *user_data) {
  ralt_tap_state.state = cur_dance(state);
  switch (ralt_tap_state.state) {
    case SINGLE_TAP:
      set_oneshot_layer(CTL_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case SINGLE_HOLD:
      register_code(KC_RALT);
      break;
    case DOUBLE_TAP:
      set_oneshot_layer(SYMBOL_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case DOUBLE_HOLD:
      layer_on(SYMBOL_LAYR);  
      break;
  }
}
void ralt_reset (tap_dance_state_t *state, void *user_data) {
  switch (ralt_tap_state.state) {
    case SINGLE_TAP:
      break;
    case SINGLE_HOLD:
      unregister_code(KC_RALT);
      break;
    case DOUBLE_TAP:
      break;
    case DOUBLE_HOLD:
      if (!is_layer_locked(SYMBOL_LAYR)) {
        layer_off(SYMBOL_LAYR);
      }
      break;
  }
  ralt_tap_state.state = 0;
}

// function for rcmd tap dance
void rcmd_finished (tap_dance_state_t *state, void *user_data) {
  rcmd_tap_state.state = cur_dance(state);
  switch (rcmd_tap_state.state) {
    case SINGLE_TAP:
      set_oneshot_layer(CTL_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case SINGLE_HOLD:
      register_code(KC_RCMD);
      break;
    case DOUBLE_TAP:
      set_oneshot_layer(MAC_SYMBOL_LAYR, ONESHOT_START);
      add_oneshot_mods(MOD_BIT(KC_ROPT));
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case DOUBLE_HOLD:
      register_code(KC_ROPT);
      if (get_highest_layer(layer_state) < 4) {
          layer_on(MAC_SYMBOL_LAYR);
      }
      break;
  }
}
void rcmd_reset (tap_dance_state_t *state, void *user_data) {
  switch (rcmd_tap_state.state) {
    case SINGLE_TAP:
      break;
    case SINGLE_HOLD:
      unregister_code(KC_RCMD);
      break;
    case DOUBLE_TAP:
      break;
    case DOUBLE_HOLD:
      if (!is_layer_locked(MAC_SYMBOL_LAYR)) {
        unregister_code(KC_ROPT);
        layer_off(MAC_SYMBOL_LAYR);
      }
      break;
  }
  rcmd_tap_state.state = 0;
}

// function for fn tap dance
void fn_finished (tap_dance_state_t *state, void *user_data) {
  fn_tap_state.state = cur_dance(state);
  switch (fn_tap_state.state) {
    case SINGLE_TAP:
      set_oneshot_layer(FN_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case SINGLE_HOLD:
      layer_on(FN_LAYR);
      break;
  }
}
void fn_reset (tap_dance_state_t *state, void *user_data) {
  switch (fn_tap_state.state) {
    case SINGLE_TAP:
      break;
    case SINGLE_HOLD:
      if (!is_layer_locked(FN_LAYR)) {
        layer_off(FN_LAYR);
      }
      break;
  }
  fn_tap_state.state = 0;
}

// function for each press of rsft
// this is needed so that pressing both shifts will activate caps_word, even when one of the shifts is a tap dance
void rsft_each(tap_dance_state_t *state, void *user_data) {
    if (get_mods() & MOD_BIT(KC_LSFT)) {
        caps_word_on();
    }
}
// function for rsft tap dance
void rsft_finished (tap_dance_state_t *state, void *user_data) {
  rsft_tap_state.state = cur_dance(state);
  switch (rsft_tap_state.state) {
    case SINGLE_TAP:
      // check if this is caps word activation, otherwise set the osl
      if (!is_caps_word_on()) {
          set_oneshot_layer(SFT_LAYR, ONESHOT_START);
          clear_oneshot_layer_state(ONESHOT_PRESSED);
      }
      break;
    case SINGLE_HOLD:
      // check if this is caps word activation, otherwise regular shift
      if (get_mods() & MOD_BIT(KC_LSFT)) {
          caps_word_on();
      }
      else {
          register_code(KC_RSFT);
      }
      break;
    case DOUBLE_TAP:
      // activate WIDE_TEXT_LAYR
      if (IS_LAYER_ON(WIDE_TEXT_LAYR)) {
          layer_lock_off(WIDE_TEXT_LAYR);
      }
      else {
          layer_lock_on(WIDE_TEXT_LAYR);
          wide_firstchar = true;
      }
      break;
    case TRIPLE_TAP:
      // activate CIRCLE_TEXT_LAYR
      if (IS_LAYER_ON(CIRCLE_TEXT_LAYR)) {
          layer_lock_off(CIRCLE_TEXT_LAYR);
      }
      else {
          layer_lock_on(CIRCLE_TEXT_LAYR);
      }
      break;
  }
}
void rsft_reset (tap_dance_state_t *state, void *user_data) {
  switch (rsft_tap_state.state) {
    case SINGLE_TAP:
      // check if this is caps word activation
      if (get_mods() & MOD_BIT(KC_LSFT)) {
          reset_oneshot_layer();
          caps_word_on();
      }
      break;
    case SINGLE_HOLD:
      if (get_mods() & MOD_BIT(KC_LSFT)) {
          caps_word_on();
      }
      else {
          unregister_code(KC_RSFT);
      }
      break;
    case DOUBLE_TAP:
      break;
    case TRIPLE_TAP:
      break;
  }
  rsft_tap_state.state = 0;
}

// function for kbunlock tap dance
void kbunlock_finished (tap_dance_state_t *state, void *user_data) {
  kbunlock_tap_state.state = cur_dance(state);
  switch (kbunlock_tap_state.state) {
    case SINGLE_TAP:
      break;
    case DOUBLE_TAP:
      break;
    case TRIPLE_TAP:
      layer_off(LOCK_LAYR); // three taps unlocks the LOCK_LAYER
      break;
    case SINGLE_HOLD:
      break;
  }
}
void kbunlock_reset (tap_dance_state_t *state, void *user_data) {
  kbunlock_tap_state.state = 0;
}

// function for each press of grv on symbol layer
void actgrv_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_A;
            break;
        case 2:
            act_char_led_index = I_E;
            break;
        case 3:
            act_char_led_index = I_I;
            break;
        case 4:
            act_char_led_index = I_O;
            break;
        case 5:
            act_char_led_index = I_U;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer grv key tap dance
void actgrv_finished (tap_dance_state_t *state, void *user_data) {
  actgrv_tap_state.state = cur_dance(state);
  switch (actgrv_tap_state.state) {
    case SINGLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00e0","00c0");
      }
      else {
        symbol_key("0224","0192", true); // a
      }
      break;
    case DOUBLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00e8","00c8");
      }
      else {
        symbol_key("0232","0200", true); // e
      }
      break;
    case TRIPLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00ec","00cc");
      }
      else {
        symbol_key("0236","0204", true); // i
      }
      break;
    case QUAD_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00f2","00d2");
      }
      else {
        symbol_key("0242","0210", true); // o
      }
      break;
    case PENT_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00f9","00d9");
      }
      else {
        symbol_key("0249","0217", true); // u
      }
      break;
    case HEXA_TAP:
      break;
  }
}
void actgrv_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    actgrv_tap_state.state = 0;
}

// function for each press of 1 on symbol layer
void act1_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_1;
            break;
        case 2:
            act_char_led_index = I_2;
            break;
        case 3:
            act_char_led_index = I_3;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer 1 key tap dance
void act1_finished (tap_dance_state_t *state, void *user_data) {
  act1_tap_state.state = cur_dance(state);
  switch (act1_tap_state.state) {
    case SINGLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00a1","00bc");
      }
      else {
        symbol_key("173","0188", true);  // inverted ! or 1/4 
      }
      break;
    case DOUBLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00bd","00bd");
      }
      else {
        symbol_key("0189","0189", true); // 1/2 
      }
      break;
    case TRIPLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00be","00be");
      }
      else {
        symbol_key("0190","0190", true); // 3/4
      }
      break;
    case QUAD_TAP:
      break;
    case PENT_TAP:
      break;
    case HEXA_TAP:
      break;
  }
}
void act1_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    act1_tap_state.state = 0;
}

// function for each press of e on symbol layer
void acte_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_E;
            break;
        case 2:
            act_char_led_index = I_A;
            break;
        case 3:
            act_char_led_index = I_I;
            break;
        case 4:
            act_char_led_index = I_O;
            break;
        case 5:
            act_char_led_index = I_U;
            break;
        case 6:
            act_char_led_index = I_Y;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer e key tap dance
void acte_finished (tap_dance_state_t *state, void *user_data) {
  acte_tap_state.state = cur_dance(state);
  switch (acte_tap_state.state) {
    case SINGLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00e9","00c9");
      }
      else {
        symbol_key("0233","0201", true); // e 
      }
      break;
    case DOUBLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00e1","00c1");
      }
      else {
        symbol_key("0225","0193", true); // a 
      }
      break;
    case TRIPLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00ed","00cd");
      }
      else {
        symbol_key("0237","0205", true); // i 
      }
      break;
    case QUAD_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00f3","00d3");
      }
      else {
        symbol_key("0243","0211", true); // o 
      }
      break;
    case PENT_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00fa","00da");
      }
      else {
        symbol_key("0250","0218", true); // u 
      }
      break;
    case HEXA_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00fd","00dd");
      }
      else {
        symbol_key("0253","0221", true); // y 
      }
      break;
  }
}
void acte_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    acte_tap_state.state = 0;
}

// function for each press of u on symbol layer
void actu_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_A;
            break;
        case 2:
            act_char_led_index = I_E;
            break;
        case 3:
            act_char_led_index = I_I;
            break;
        case 4:
            act_char_led_index = I_O;
            break;
        case 5:
            act_char_led_index = I_U;
            break;
        case 6:
            act_char_led_index = I_Y;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer u key tap dance
void actu_finished (tap_dance_state_t *state, void *user_data) {
  actu_tap_state.state = cur_dance(state);
  switch (actu_tap_state.state) {
    case SINGLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00e4","00c4");
      }
      else {
        symbol_key("0228","0196", true); // a 
      }
      break;
    case DOUBLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00eb","00cb");
      }
      else {
        symbol_key("0235","0203", true); // e 
      }
      break;
    case TRIPLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00ef","00cf");
      }
      else {
        symbol_key("0239","0207", true); // i 
      }
      break;
    case QUAD_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00f6","00d6");
      }
      else {
        symbol_key("0246","0214", true); // o 
      }
      break;
    case PENT_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00fc","00dc");
      }
      else {
        symbol_key("0252","0220", true); // u 
      }
      break;
    case HEXA_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00ff","0178");
      }
      else {
        symbol_key("0255","0159", true); // y 
      }
      break;
  }
}
void actu_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    actu_tap_state.state = 0;
}

// function for each press of i on symbol layer
void acti_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_I;
            break;
        case 2:
            act_char_led_index = I_A;
            break;
        case 3:
            act_char_led_index = I_E;
            break;
        case 4:
            act_char_led_index = I_O;
            break;
        case 5:
            act_char_led_index = I_U;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer i key tap dance
void acti_finished (tap_dance_state_t *state, void *user_data) {
  acti_tap_state.state = cur_dance(state);
  switch (acti_tap_state.state) {
    case SINGLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00ee","00ce");
      }
      else {
        symbol_key("0238","0206", true); // i 
      }
      break;
    case DOUBLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00e2","00c2");
      }
      else {
        symbol_key("0226","0194", true); // a 
      }
      break;
    case TRIPLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00ea","00ca");
      }
      else {
        symbol_key("0234","0202", true); // e 
      }
      break;
    case QUAD_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00f4","00d4");
      }
      else {
        symbol_key("0244","0212", true); // o 
      }
      break;
    case PENT_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00fb","00db");
      }
      else {
        symbol_key("0251","0219", true); // u 
      }
      break;
    case HEXA_TAP:
      break;
  }
}
void acti_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    acti_tap_state.state = 0;
}

// function for each press of n on symbol layer
void actn_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_N;
            break;
        case 2:
            act_char_led_index = I_A;
            break;
        case 3:
            act_char_led_index = I_O;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer n key tap dance
void actn_finished (tap_dance_state_t *state, void *user_data) {
  actn_tap_state.state = cur_dance(state);
  switch (actn_tap_state.state) {
    case SINGLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00f1","00d1");
      }
      else {
        symbol_key("164","165", true);   // n 
      }
      break;
    case DOUBLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00e3","00c3");
      }
      else {
        symbol_key("0227","0195", true); // a 
      }
      break;
    case TRIPLE_TAP:
      if (user_config.is_linux_base) {
        symbol_key_linux("00f5","00d5");
      }
      else {
        symbol_key("0245","0213", true); // o 
      }
      break;
  }
}
void actn_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    actn_tap_state.state = 0;
}

// function for lgui tap dance
void lgui_finished (tap_dance_state_t *state, void *user_data) {
  lgui_tap_state.state = cur_dance(state);
  switch (lgui_tap_state.state) {
    case SINGLE_TAP:
      tap_code(KC_LGUI);
      break;
    case SINGLE_HOLD:
      register_code(KC_LGUI);
      if (!is_mac_base()) {
        is_winkey_held = true;
      }
      break;
    case DOUBLE_TAP:
      set_oneshot_layer(SYMBOL_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case DOUBLE_HOLD:
      layer_on(SYMBOL_LAYR);  
      break;
  }
}
void lgui_reset (tap_dance_state_t *state, void *user_data) {
  switch (lgui_tap_state.state) {
    case SINGLE_TAP:
      break;
    case SINGLE_HOLD:
      unregister_code(KC_LGUI);
      if (!is_mac_base()) {
        is_winkey_held = false;
      }
      break;
    case DOUBLE_TAP:
      break;
    case DOUBLE_HOLD:
      if (!is_layer_locked(SYMBOL_LAYR)) {
        layer_off(SYMBOL_LAYR);
      }
      break;
  }
  lgui_tap_state.state = 0;
}

// function for lopt tap dance
void lopt_finished (tap_dance_state_t *state, void *user_data) {
  lopt_tap_state.state = cur_dance(state);
  switch (lopt_tap_state.state) {
    case SINGLE_TAP:
      tap_code(KC_LOPT);
      break;
    case SINGLE_HOLD:
    case DOUBLE_HOLD:
      register_code(KC_LOPT);
      if (get_highest_layer(layer_state) < FN_LAYR) {
        layer_on(MAC_SYMBOL_LAYR);
      }
      break;
    case DOUBLE_TAP:
      set_oneshot_layer(MAC_SYMBOL_LAYR, ONESHOT_START);
      add_oneshot_mods(MOD_BIT(KC_LOPT));
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
  }
}
void lopt_reset (tap_dance_state_t *state, void *user_data) {
  switch (lopt_tap_state.state) {
    case SINGLE_TAP:
      break;
    case SINGLE_HOLD:
    case DOUBLE_HOLD:
      if (!is_layer_locked(MAC_SYMBOL_LAYR)) {
        unregister_code(KC_LOPT);
        layer_off(MAC_SYMBOL_LAYR);
      }
      break;
    case DOUBLE_TAP:
      break;
  }
  lopt_tap_state.state = 0;
}

// associate the tap dance keys with their funcitons
tap_dance_action_t tap_dance_actions[] = {
  [CAPS_LAYR] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, caps_finished, caps_reset),
  [FN_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, fn_finished, fn_reset),
  [RALT_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, ralt_finished, ralt_reset),
  [RSFT_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(rsft_each, rsft_finished, rsft_reset),
  [KB_UNLOCK] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, kbunlock_finished, kbunlock_reset),
  [ACT_GRV] = ACTION_TAP_DANCE_FN_ADVANCED(actgrv_each, actgrv_finished, actgrv_reset),
  [ACT_1] = ACTION_TAP_DANCE_FN_ADVANCED(act1_each, act1_finished, act1_reset),
  [ACT_E] = ACTION_TAP_DANCE_FN_ADVANCED(acte_each, acte_finished, acte_reset),
  [ACT_U] = ACTION_TAP_DANCE_FN_ADVANCED(actu_each, actu_finished, actu_reset),
  [ACT_I] = ACTION_TAP_DANCE_FN_ADVANCED(acti_each, acti_finished, acti_reset),
  [ACT_N] = ACTION_TAP_DANCE_FN_ADVANCED(actn_each, actn_finished, actn_reset),
  [LGUI_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, lgui_finished, lgui_reset),
  [RCMD_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, rcmd_finished, rcmd_reset),
  [LOPT_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, lopt_finished, lopt_reset),
};

// accent tap dances should give a little bit longer to see the leds
uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case TD(ACT_GRV):
        case TD(ACT_1):
        case TD(ACT_E):
        case TD(ACT_U):
        case TD(ACT_I):
        case TD(ACT_N):
            return TAPPING_TERM + 400;
        default:
            return TAPPING_TERM;
    }
}

// this is needed to prevent CAPS_WORD from breaking when some custom key commands are used
bool caps_word_press_user(uint16_t keycode) {
    switch (keycode) {
        // Keycodes that continue Caps Word, with shift applied.
        case KC_A ... KC_Z:
        case KC_MINS:
            add_weak_mods(MOD_BIT(KC_LSFT));  // Apply shift to next key.
            return true;

        // Keycodes that continue Caps Word, without shifting.
        case KC_1 ... KC_0:
        case KC_BSPC:
        case KC_DEL:
        case KC_UNDS:
        case BSPCFAST:
            return true;

        default:
            return false;  // Deactivate Caps Word.
    }
}

// setup to store vars when macro recording starts or ends. then can flash some rgb
bool dynamic_macro_record_start_user(int8_t direction) {
    macro_direction = direction;
    macro_recording = true;
    macro_timer = timer_read();
    return true;
}
bool dynamic_macro_record_end_user(int8_t direction) {
    macro_direction = direction;
    macro_recording = false;
    is_macro_led_on = false;
    // this loop is needed to prevent a stuck led after a macro finishes recording
    for (int i = 0; i < tk_length; i++) {
        if (tracked_keys[i].index == I_MREC1 || tracked_keys[i].index == I_MREC2) {
            tracked_keys[i].press = false;
            tracked_keys[i].fade = 0;
        }
    }
    return true;
}
// this is so the macro key lights don't get stuck when i play the macro
bool dynamic_macro_play_user(int8_t direction) {
    for (int i = 0; i < tk_length; i++) {
        if (tracked_keys[i].index == I_MPLY1 || tracked_keys[i].index == I_MPLY2) {
            tracked_keys[i].press = false;
            tracked_keys[i].fade = 0;
        }
    }
    return true;
}

void oneshot_layer_changed_user(uint8_t layer) {
    if (layer > 1) {
        oneshot_layer_active = true;
    }
    if (!layer) {
        oneshot_layer_active = false;
    }
}

void layer_lock_set_user(layer_state_t locked_layers) {
    static bool opt_is_held_for_symbol = false;
    if (is_layer_locked(MAC_SYMBOL_LAYR)) {
        register_code(KC_LOPT);
        opt_is_held_for_symbol = true;
    }
    else if (opt_is_held_for_symbol) {
        unregister_code(KC_LOPT);
        opt_is_held_for_symbol = false;
    }
}

void leader_start_user(void) {
    is_in_leader_sequence = true;
}

void leader_end_user(void) {
    if (leader_sequence_three_keys(KC_L, KC_L, KC_S)) {        // layer lock SFT_LAYR
        if (is_layer_locked(SFT_LAYR)) {
            layer_lock_off(SFT_LAYR);
        }
        else {
            layer_lock_on(SFT_LAYR);
        }
    }
    else if (leader_sequence_three_keys(KC_L, KC_L, KC_A)) {   // layer lock CTL_LAYR (now on ALT key)
        if (is_layer_locked(CTL_LAYR)) {
            layer_lock_off(CTL_LAYR);
        }
        else {
            layer_lock_on(CTL_LAYR);
        }
    }
    else if (leader_sequence_three_keys(KC_L, KC_L, KC_F)) {   // layer lock FN_LAYR
        if (is_layer_locked(FN_LAYR)) {
            layer_lock_off(FN_LAYR);
        }
        else {
            layer_lock_on(FN_LAYR);
        }
    }
    else if (leader_sequence_three_keys(KC_L, KC_L, KC_T)) {   // layer lock TMUX_LAYR
        if (is_layer_locked(TMUX_LAYR)) {
            layer_lock_off(TMUX_LAYR);
        }
        else {
            layer_lock_on(TMUX_LAYR);
        }
    }
    else if (leader_sequence_four_keys(KC_L, KC_L, KC_S, KC_M)) {   // layer lock SYMBOL_LAYR
        if (is_mac_base()) {
            if (is_layer_locked(MAC_SYMBOL_LAYR)) {
                layer_lock_off(MAC_SYMBOL_LAYR);
            }
            else {
                layer_lock_on(MAC_SYMBOL_LAYR);
            }
        }
        else {
            if (is_layer_locked(SYMBOL_LAYR)) {
                layer_lock_off(SYMBOL_LAYR);
            }
            else {
                layer_lock_on(SYMBOL_LAYR);
            }
        }
    }
    else if (leader_sequence_four_keys(KC_L, KC_O, KC_C, KC_K)) {   // switch to LOCK_LAYR
        layer_on(LOCK_LAYR);
    }
    else if (leader_sequence_two_keys(KC_L, KC_K)) {                // set key lock watch
        set_key_lock_watching();
    }
    else if (leader_sequence_two_keys(KC_O, KC_S)) {                 // change os
        // cycle mac->linux->windows->mac
        /*if (is_mac_base()) {
            if (IS_LAYER_ON(MAC_BASE2_LAYR)) {
                set_single_persistent_default_layer(BASE2_LAYR);
                layer_move(BASE2_LAYR);
            }
            else {
                set_single_persistent_default_layer(BASE_LAYR);
                layer_move(BASE_LAYR);
            }
            if (!user_config.is_linux_base) {
                user_config.is_linux_base = true;
                eeconfig_update_user(user_config.raw);
            }
        }
        else if (user_config.is_linux_base) {
            user_config.is_linux_base = false;
            eeconfig_update_user(user_config.raw);
        }
        else {
            if (IS_LAYER_ON(BASE2_LAYR)) {
                set_single_persistent_default_layer(MAC_BASE2_LAYR);
                layer_move(MAC_BASE2_LAYR);
            }
            else {
                set_single_persistent_default_layer(MAC_BASE_LAYR);
                layer_move(MAC_BASE_LAYR);
            }
        }*/
        // just show which os is currently set
        os_changed = true;
    }
    else if (leader_sequence_three_keys(KC_M, KC_A, KC_C)) {         // change to mac os
        if (!is_mac_base()) {
            if (IS_LAYER_ON(BASE2_LAYR) || layer_state_cmp(default_layer_state, BASE2_LAYR)) {
                set_single_persistent_default_layer(MAC_BASE2_LAYR);
                layer_move(MAC_BASE2_LAYR);
            }
            else {
                set_single_persistent_default_layer(MAC_BASE_LAYR);
                layer_move(MAC_BASE_LAYR);
            }
        }
        os_changed = true;
    }
    else if (leader_sequence_three_keys(KC_W, KC_I, KC_N)) {         // change to windows os
        if (is_mac_base()) {
            if (IS_LAYER_ON(MAC_BASE2_LAYR) || layer_state_cmp(default_layer_state, MAC_BASE2_LAYR)) {
                set_single_persistent_default_layer(BASE2_LAYR);
                layer_move(BASE2_LAYR);
            }
            else {
                set_single_persistent_default_layer(BASE_LAYR);
                layer_move(BASE_LAYR);
            }
        }
        if (user_config.is_linux_base) {
            user_config.is_linux_base = false;
            eeconfig_update_user(user_config.raw);
        }
        os_changed = true;
    }
    else if (leader_sequence_three_keys(KC_L, KC_I, KC_N)) {         // change to linux os
        if (is_mac_base()) {
            if (IS_LAYER_ON(MAC_BASE2_LAYR) || layer_state_cmp(default_layer_state, MAC_BASE2_LAYR)) {
                set_single_persistent_default_layer(BASE2_LAYR);
                layer_move(BASE2_LAYR);
            }
            else {
                set_single_persistent_default_layer(BASE_LAYR);
                layer_move(BASE_LAYR);
            }
        }
        if (!user_config.is_linux_base) {
            user_config.is_linux_base = true;
            eeconfig_update_user(user_config.raw);
        }
        os_changed = true;
    }
    else if (leader_sequence_four_keys(KC_B, KC_A, KC_S, KC_E)) {   // change default BASE layer
        int b_layer = is_mac_base() ? MAC_BASE_LAYR : BASE_LAYR;
        int b2_layer = is_mac_base() ? MAC_BASE2_LAYR : BASE2_LAYR;
        if (IS_LAYER_ON(b_layer))
        {
            set_single_persistent_default_layer(b2_layer);
            layer_move(b2_layer);
        }
        else
        {
            set_single_persistent_default_layer(b_layer);
            layer_move(b_layer);
        }
        base_layer_changed = true;
    }
    else if (leader_sequence_five_keys(KC_C, KC_O, KC_L, KC_O, KC_R)) { // start the color test
        color_test_timer = timer_read();
        color_test = true;
    }
    else if (leader_sequence_two_keys(KC_R, KC_T)) {          // rpi temp monitor
        SEND_STRING("rpi/temperature.sh" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_R, KC_U)) {          // rpi uptime monitor
        SEND_STRING("rpi/uptime.sh" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_P, KC_R)) {          // restart pi-hole
        SEND_STRING("sudo service pihole-FTL restart" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_M, KC_A)) {          // sudo mount -a
        SEND_STRING("sudo mount -a" SS_TAP(X_ENT));
    }
    else if (leader_sequence_three_keys(KC_P, KC_O, KC_C)) {  // insert test POC data for template
        send_string_with_delay("Firstname" SS_TAP(X_TAB) "Lastname" SS_TAP(X_TAB) "123-456-7890" SS_TAP(X_TAB) "first.last@mail.mil" SS_TAP(X_TAB),10);
    }
    else if (leader_sequence_two_keys(KC_N, KC_1)) {          // mac mini start nut upsdrvctl
        SEND_STRING("sudo /usr/local/opt/nut/sbin/upsdrvctl start" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_N, KC_2)) {          // mac mini start nut upsd
        SEND_STRING("sudo /usr/local/opt/nut/sbin/upsd" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_N, KC_R)) {          // restart nut
        SEND_STRING("sudo service nut-server restart" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_U, KC_R)) {          // restart unifi
        SEND_STRING("sudo service unifi restart" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_U, KC_U)) {          // update unifi
        if (is_mac_base()) {  
          SEND_STRING("wget https://get.glennr.nl/unifi/update/unifi-update.sh && sudo bash unifi-update.sh --custom-url " SS_LCMD(SS_TAP(X_V)) SS_TAP(X_ENT));
        }   
        else {  
          SEND_STRING("wget https://get.glennr.nl/unifi/update/unifi-update.sh && sudo bash unifi-update.sh --custom-url " SS_LCTL(SS_TAP(X_V)) SS_TAP(X_ENT));
        }
    }
    else if (leader_sequence_two_keys(KC_V, KC_H)) {          // open hosts file in vi
        SEND_STRING("sudo vi /etc/hosts" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_V, KC_A)) {          // open tb authorized in vi
        SEND_STRING("sudo vi /sys/bus/thunderbolt/devices/0-3/authorized" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_S, KC_W)) {          // select word
        if (is_mac_base()) {
            SEND_STRING(SS_LOPT(SS_TAP(X_LEFT) SS_LSFT(SS_TAP(X_RIGHT))));
        }
        else {
            SEND_STRING(SS_LCTL(SS_TAP(X_LEFT) SS_LSFT(SS_TAP(X_RIGHT))));
        }
    }
    else if (leader_sequence_two_keys(KC_S, KC_L)) {          // select line
        SEND_STRING(SS_TAP(X_HOME) SS_LSFT(SS_TAP(X_END)));
    }
    else if (leader_sequence_two_keys(KC_T, KC_Y)) {          // thank you
        SEND_STRING("thank you");
    }
    else if (leader_sequence_two_keys(KC_N, KC_P)) {          // no problem
        SEND_STRING("no problem");
    }
    else if (leader_sequence_three_keys(KC_O, KC_M, KC_W)) {  // on my way
        SEND_STRING("on my way");
    }
    else if (leader_sequence_three_keys(KC_B, KC_R, KC_B)) {  // be right back
        SEND_STRING("be right back");
    }
    else if (leader_sequence_three_keys(KC_H, KC_G, KC_E)) {  // have a good evening 
        SEND_STRING("have a good evening");
    }
    else if (leader_sequence_three_keys(KC_H, KC_G, KC_N)) {  // have a good night 
        SEND_STRING("have a good night");
    }
    else if (leader_sequence_four_keys(KC_T, KC_T, KC_Y, KC_L)) {  // talk to you later
        SEND_STRING("talk to you later");
    }
    else if (leader_sequence_four_keys(KC_G, KC_I, KC_T, KC_L)) {        // git log
        SEND_STRING("git log\n");
    }
    else if (leader_sequence_four_keys(KC_G, KC_I, KC_T, KC_A)) {        // git add
        SEND_STRING("git add -A\n");
    }
    else if (leader_sequence_four_keys(KC_G, KC_I, KC_T, KC_C)) {        // git commit
        SEND_STRING("git commit -m \"\"" SS_TAP(X_LEFT));
    }
    else if (leader_sequence_four_keys(KC_G, KC_I, KC_T, KC_P)) {        // git push
        SEND_STRING("git push\n");
    }
    else if (leader_sequence_five_keys(KC_G, KC_I, KC_T, KC_C, KC_O)) {  // git checkout .
        SEND_STRING("git checkout .\n");
    }
    else if (leader_sequence_three_keys(KC_Q, KC_C, KC_B)) {  // qmk compile shortcutstudio bridge75 firmware
        SEND_STRING("qmk compile -kb shortcut/bridge75 -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_three_keys(KC_Q, KC_F, KC_B)) {  // qmk flash shortcutstudio bridge75 firmware
        SEND_STRING("qmk flash -kb shortcut/bridge75 -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_three_keys(KC_Q, KC_C, KC_Y)) {  // qmk compile yunzii firmware
        SEND_STRING("qmk compile -kb yunzii/al68 -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_three_keys(KC_Q, KC_F, KC_Y)) {  // qmk flash yunzii firmware
        SEND_STRING("qmk flash -kb yunzii/al68 -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_three_keys(KC_Q, KC_C, KC_L)) {  // qmk compile lemokey p1 firmware
        SEND_STRING("qmk compile -kb lemokey/p1_pro/ansi_encoder -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_three_keys(KC_Q, KC_F, KC_L)) {  // qmk flash lemokey p1 firmware
        SEND_STRING("qmk flash -kb lemokey/p1_pro/ansi_encoder -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_four_keys(KC_Q, KC_C, KC_K, KC_V)) {  // qmk compile keychron V6 firmware
        SEND_STRING("qmk compile -kb keychron/v6_max/ansi_encoder -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_four_keys(KC_Q, KC_F, KC_K, KC_V)) {  // qmk flash keychron V6 firmware
        SEND_STRING("qmk flash -kb keychron/v6_max/ansi_encoder -km djcastaldo" SS_TAP(X_ENT));
    }                       
    else if (leader_sequence_four_keys(KC_Q, KC_C, KC_K, KC_Q)) {  // qmk compile keychron Q6 firmware
        SEND_STRING("qmk compile -kb keychron/q6_max/ansi_encoder -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_four_keys(KC_Q, KC_F, KC_K, KC_Q)) {  // qmk flash keychron Q6 firmware
        SEND_STRING("qmk flash -kb keychron/q6_max/ansi_encoder -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_five_keys(KC_A, KC_S, KC_P, KC_D, KC_C)) {  // asp.net decrypt connectionStrings path from clipboard
        send_string_with_delay("C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\aspnet_regiis -pdf connectionStrings " SS_LCTL(SS_TAP(X_V)) SS_TAP(X_ENT),9);
    }
    else if (leader_sequence_five_keys(KC_A, KC_S, KC_P, KC_E, KC_C)) {  // asp.net encrypt connectionStrings path from clipboard
        send_string_with_delay("C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\aspnet_regiis -pef connectionStrings " SS_LCTL(SS_TAP(X_V)) SS_TAP(X_ENT),9);
    }
    else if (leader_sequence_five_keys(KC_A, KC_S, KC_P, KC_D, KC_S)) {  // asp.net decrypt sessionState path from clipboard
        send_string_with_delay("C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\aspnet_regiis -pdf system.web/sessionState " SS_LCTL(SS_TAP(X_V)) SS_TAP(X_ENT),9);
    }
    else if (leader_sequence_five_keys(KC_A, KC_S, KC_P, KC_E, KC_S)) {  // asp.net encrypt sessionState path from clipboard
        send_string_with_delay("C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\aspnet_regiis -pef system.web/sessionState " SS_LCTL(SS_TAP(X_V)) SS_TAP(X_ENT),9);
    }
    // if process_leader_secrets returns false, a secret leader sequence ran and leader matching should stop
    // if true, no secrets match and leader matching continues here.
    else if (process_leader_secrets()) {
        // leader sequence failed, so blink the rgb red a few times
        is_leader_error = true;
        leader_error_token = defer_exec(1500, leader_error_callback, NULL);  // Schedule callback.
    }

    is_in_leader_sequence = false;
}

void keyboard_post_init_user(void) {
    // read the user config from EEPROM
    user_config.raw = eeconfig_read_user();
    // and set this so layers switch correctly on user's first os change
    layer_state_set(default_layer_state);
}

void eeconfig_init_user(void) {  // EEPROM is getting reset!
    user_config.raw = 0;
    user_config.is_linux_base = false; // set default here
    eeconfig_update_user(user_config.raw); // write default value to EEPROM now
    set_single_persistent_default_layer(BASE2_LAYR);
}
