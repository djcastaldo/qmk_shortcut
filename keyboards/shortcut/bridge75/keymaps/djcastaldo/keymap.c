// 05/13/2025 (@davex)
// SPDX-License-Identifier: GPL-2.0-or-later

#include QMK_KEYBOARD_H
#include "print.h"
#include "features/layer_lock.h"

__attribute__ ((weak))
bool process_record_secrets(uint16_t keycode, keyrecord_t *record) {
  return true;
}
__attribute__ ((weak))
bool process_leader_secrets(void) {
  return true;
}

// layer identifiers
enum layers {
    BASE_LAYR,
    BASE2_LAYR,
    MAC_BASE_LAYR,
    MAC_BASE2_LAYR,
    FN_LAYR,
    SFT_LAYR,
    CTL_LAYR,
    TMUX_LAYR,
    SYMBOL_LAYR,
    MAC_SYMBOL_LAYR,
    WIDE_TEXT_LAYR,
    LOCK_LAYR
};


// custom keycodes
enum custom_keycodes {
    BSPCFAST = NEW_SAFE_RANGE,
    ARROW,
    WAVE,
    LLOCK,
    DUAL_PLUSMIN,
    DUAL_MULTDIV,
    DUAL_F12,
    DUAL_ESC,
    VI_REPLACE,
    GIT_ADD,
    GIT_COMMIT,
    GIT_PUSH,
    GIT_CHKOUT,
    GIT_LOG,
    FJLIGHT,
    HROWLIGHT,
    KTRACK,
    BASE_CHG,
    MK_HOLD,
    MK_REL,
    MK_ACCEL0,
    MK_ACCEL2,
    TMUXLKEY,
    TMUXLCMD,
    TMONON,
    TMONOF,
    TVISON,
    TVISOF,
    TWINLFT,
    TWINRGT,
    TJPANE,
    LTRANS,
    OPT2,
    OPT3,
    OPT4,
    OPT5,
    OPT6,
    OPT7,
    OPT8,
    OPT9,
    OPT0,
    OPTMIN,
    OPTEQ,
    OPTQ,
    OPTW,
    OPTR,
    OPTT,
    OPTY,
    OPTO,
    OPTP,
    OPTLBR,
    OPTRBR,
    OPTBSL,
    OPTA,
    OPTS,
    OPTD,
    OPTF,
    OPTG,
    OPTH,
    OPTJ,
    OPTK,
    OPTL,
    OPTSEM,
    OPTAPO,
    OPTZ,
    OPTX,
    OPTC,
    OPTV,
    OPTB,
    OPTM,
    OPTCOM,
    OPTDOT,
    OPTSLS,
    SUITH,
    SUITD,
    SUITC,
    SUITS,
    SUP1,
    SUP2,
    SUP3,
    NBSP,
    WM_SYM,
    STHRU,
    UNDERLN,
    BARTEXT,
    COLORTEST,
    FLASH_KB,
    BOOTLDR
};

// custom tap dances
enum {
    CAPS_LAYR = 0,
    FN_OSL = 1,
    RSFT_OSL = 2,
    RALT_OSL = 3,
    KB_UNLOCK = 4,
    ACT_GRV = 5,
    ACT_1   = 6,
    ACT_E   = 7,
    ACT_U   = 8,
    ACT_I   = 9,
    ACT_N   = 10,
    LGUI_OSL = 11,
    RCMD_OSL = 12,
    LOPT_OSL = 13
};


// all the keymaps with their defined keycodes
// clang-format off
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
//  [BASE_LAYR]
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |D_Esc |    | F1   || F2   || F3   || F4   |    | F5   || F6   || F7   || F8   |    | F9   || F10  || F11  ||D_F12 |    | Del  |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  | `    || 1    || 2    || 3    || 4    || 5    || 6    || 7    || 8    || 9    || 0    || -    || =    || Backspace    || Home |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  | LT(TMUX) || Q    || W    || E    || R    || T    || Y    || U    || I    || O    || P    || [    || ]    || \        || PgUp |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  | TD(CAPS)    || A    || S    || D    || F    || G    || H    || J    || K    || L    || ;    || '    || Enter         || PgDn |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  | LShift          || Z    || X    || C    || V    || B    || N    || M    || ,    || .    || /    ||TD(RSFT)   || Up   || End  |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  | Ctrl    ||TD(GUI) || Alt     || Space                                        ||TD(RALT) ||TD(FN)   |  | Left || Down || Rght |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [BASE_LAYR] = LAYOUT_ansi(
        DUAL_ESC,   KC_F1,  KC_F2,  KC_F3,  KC_F4,      KC_F5,  KC_F6,  KC_F7,  KC_F8,      KC_F9, KC_F10, KC_F11, DUAL_F12,    KC_DEL,
        KC_GRV,  KC_1,   KC_2,   KC_3,   KC_4,   KC_5,   KC_6,   KC_7,   KC_8,   KC_9,   KC_0, KC_MINS, KC_EQL,   BSPCFAST,     KC_HOME,
        LT(TMUX_LAYR,KC_TAB),  KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y,   KC_U,   KC_I,   KC_O,   KC_P, KC_LBRC, KC_RBRC, KC_BSLS,   KC_PGUP,
        TD(CAPS_LAYR),  KC_A,   KC_S,   KC_D,   KC_F,   KC_G,   KC_H,   KC_J,    KC_K,  KC_L,  KC_SCLN, KC_QUOT,    KC_ENT,     KC_PGDN,
        KC_LSFT,            KC_Z,   KC_X,   KC_C,   KC_V,   KC_B,   KC_N,  KC_M, KC_COMM, KC_DOT, KC_SLSH, TD(RSFT_OSL), KC_UP, KC_END,
        KC_LCTL, TD(LGUI_OSL), KC_LALT,                   KC_SPC,                   TD(RALT_OSL), TD(FN_OSL), KC_LEFT, KC_DOWN, KC_RGHT
    ),

//  [BASE2_LAYR]
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |D_Esc |    | F1   || F2   || F3   || F4   |    | F5   || F6   || F7   || F8   |    | F9   || F10  || F11  ||D_F12 |    | Del  |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  | `    || 1    || 2    || 3    || 4    || 5    || 6    || 7    || 8    || 9    || 0    || -    || =    || Backspace    || Home |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  | LT(TMUX) || Q    || W    || E    || R    || T    || Y    || U    || I    || O    || P    || [    || ]    || \        || End  |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  | TD(CAPS)    || A    || S    || D    || F    || G    || H    || J    || K    || L    || ;    || '    || Enter         || PgUp |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  | LShift          || Z    || X    || C    || V    || B    || N    || M    || ,    || .    || /    ||TD(RSFT)   || Up   || PgDn |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  | Ctrl    ||TD(GUI) || Alt     || Space                                        ||TD(RALT) ||TD(FN)   |  | Left || Down || Rght |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [BASE2_LAYR] = LAYOUT_ansi(
        DUAL_ESC,   KC_F1,  KC_F2,  KC_F3,  KC_F4,      KC_F5,  KC_F6,  KC_F7,  KC_F8,      KC_F9,  KC_F10, KC_F11, DUAL_F12,   KC_DEL,
        KC_GRV,  KC_1,  KC_2,   KC_3,   KC_4,   KC_5,   KC_6,   KC_7,    KC_8,  KC_9,   KC_0,  KC_MINS, KC_EQL,   BSPCFAST,     KC_HOME,
        LT(TMUX_LAYR,KC_TAB), KC_Q, KC_W, KC_E, KC_R, KC_T,  KC_Y,   KC_U,    KC_I,  KC_O,   KC_P, KC_LBRC, KC_RBRC,  KC_BSLS,  KC_END,
        TD(CAPS_LAYR),  KC_A,   KC_S,   KC_D,   KC_F,   KC_G,   KC_H,   KC_J,   KC_K,   KC_L, KC_SCLN, KC_QUOT,    KC_ENT,      KC_PGUP,
        KC_LSFT,            KC_Z,   KC_X,   KC_C,   KC_V,   KC_B,   KC_N,  KC_M, KC_COMM, KC_DOT, KC_SLSH, TD(RSFT_OSL), KC_UP, KC_PGDN,
        KC_LCTL, TD(LGUI_OSL), KC_LALT,                   KC_SPC,                   TD(RALT_OSL), TD(FN_OSL), KC_LEFT, KC_DOWN, KC_RGHT
    ),

//  [MAC_BASE_LAYR]
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |D_Esc |    | F1   || F2   || F3   || F4   |    | F5   || F6   || F7   || F8   |    | F9   || F10  || F11  ||D_F12 |    | Del  |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  | `    || 1    || 2    || 3    || 4    || 5    || 6    || 7    || 8    || 9    || 0    || -    || =    || Backspace    || Home |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  | LT(TMUX) || Q    || W    || E    || R    || T    || Y    || U    || I    || O    || P    || [    || ]    || \        || PgUp |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  | TD(CAPS)    || A    || S    || D    || F    || G    || H    || J    || K    || L    || ;    || '    || Enter         || PgDn |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  | LShift          || Z    || X    || C    || V    || B    || N    || M    || ,    || .    || /    ||TD(RSFT)   || Up   || End  |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  | Ctrl    || Option || Command || Space                                        ||TD(RCMD) ||TD(FN)   |  | Left || Down || Rght |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [MAC_BASE_LAYR] = LAYOUT_ansi(
        DUAL_ESC,   KC_F1,  KC_F2,  KC_F3,  KC_F4,      KC_F5,  KC_F6,  KC_F7,  KC_F8,      KC_F9, KC_F10, KC_F11, DUAL_F12,    KC_DEL,
        KC_GRV,  KC_1,   KC_2,   KC_3,   KC_4,   KC_5,   KC_6,   KC_7,   KC_8,   KC_9,   KC_0, KC_MINS, KC_EQL,   BSPCFAST,     KC_HOME,
        LT(TMUX_LAYR,KC_TAB),  KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y,   KC_U,   KC_I,   KC_O,   KC_P, KC_LBRC, KC_RBRC, KC_BSLS,   KC_PGUP,
        TD(CAPS_LAYR),  KC_A,   KC_S,   KC_D,   KC_F,   KC_G,   KC_H,   KC_J,    KC_K,  KC_L,  KC_SCLN, KC_QUOT,    KC_ENT,     KC_PGDN,
        KC_LSFT,            KC_Z,   KC_X,   KC_C,   KC_V,   KC_B,   KC_N,  KC_M, KC_COMM, KC_DOT, KC_SLSH, TD(RSFT_OSL), KC_UP, KC_END,
        KC_LCTL, TD(LOPT_OSL), KC_LCMD,                   KC_SPC,                   TD(RCMD_OSL), TD(FN_OSL), KC_LEFT, KC_DOWN, KC_RGHT
    ),

//  [MAC_BASE2_LAYR]
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |D_Esc |    | F1   || F2   || F3   || F4   |    | F5   || F6   || F7   || F8   |    | F9   || F10  || F11  ||D_F12 |    | Del  |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  | `    || 1    || 2    || 3    || 4    || 5    || 6    || 7    || 8    || 9    || 0    || -    || =    || Backspace    || Home |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  | LT(TMUX) || Q    || W    || E    || R    || T    || Y    || U    || I    || O    || P    || [    || ]    || \        || End  |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  | TD(CAPS)    || A    || S    || D    || F    || G    || H    || J    || K    || L    || ;    || '    || Enter         || PgUp |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  | LShift          || Z    || X    || C    || V    || B    || N    || M    || ,    || .    || /    ||TD(RSFT)   || Up   || PgDn |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  | Ctrl    || Option || Command || Space                                        ||TD(RCMD) ||TD(FN)   |  | Left || Down || Rght |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [MAC_BASE2_LAYR] = LAYOUT_ansi(
        DUAL_ESC,   KC_F1,  KC_F2,  KC_F3,  KC_F4,      KC_F5,  KC_F6,  KC_F7,  KC_F8,      KC_F9,  KC_F10, KC_F11, DUAL_F12,   KC_DEL,
        KC_GRV,  KC_1,  KC_2,   KC_3,   KC_4,   KC_5,   KC_6,   KC_7,    KC_8,  KC_9,   KC_0,  KC_MINS, KC_EQL,   BSPCFAST,     KC_HOME,
        LT(TMUX_LAYR,KC_TAB), KC_Q, KC_W, KC_E, KC_R, KC_T,  KC_Y,   KC_U,    KC_I,  KC_O,   KC_P, KC_LBRC, KC_RBRC,  KC_BSLS,  KC_END,
        TD(CAPS_LAYR),  KC_A,   KC_S,   KC_D,   KC_F,   KC_G,   KC_H,   KC_J,   KC_K,   KC_L, KC_SCLN, KC_QUOT,    KC_ENT,      KC_PGUP,
        KC_LSFT,            KC_Z,   KC_X,   KC_C,   KC_V,   KC_B,   KC_N,  KC_M, KC_COMM, KC_DOT, KC_SLSH, TD(RSFT_OSL), KC_UP, KC_PGDN,
        KC_LCTL, TD(LOPT_OSL), KC_LCMD,                   KC_SPC,                   TD(RCMD_OSL), TD(FN_OSL), KC_LEFT, KC_DOWN, KC_RGHT
    ),

//  [FN_LAYR] (green)
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |      |    |      ||      ||ViRepl||      |    |ChkOut||      ||      ||GitLog|    |GitAdd||Commit||      || Push |    | Ins  |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  |      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||Arrow || Wave ||              ||LLock |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  | MO(TMUX) ||WMail2||WMail1||Mail  ||RPhone||WPhone||      ||      ||      ||      ||      || Rec1 || Rec2 ||          ||      |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  |             ||Addr  ||City  ||ZIP   ||Phone ||      ||      ||      ||      || Lead ||SLock || PScr ||               ||      |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  | MO(SFT)         ||      ||Rout  ||Acct  ||      ||      ||      ||      || Ply1 || Ply2 ||Pause || MO(SFT)   ||      ||      |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  |         || WM_SYM || MO(CTL) || Space                                        || MO(CTL) ||         |  |      ||      ||      |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [FN_LAYR] = LAYOUT_ansi(
        _______,_______,_______, VI_REPLACE, _______, GIT_CHKOUT, _______,_______, GIT_LOG, GIT_ADD, GIT_COMMIT,_______, GIT_PUSH, KC_INS,
        _______,_______,_______, _______, _______, _______, _______, _______, _______, _______, _______, ARROW, WAVE,  _______,     LLOCK,
        MO(TMUX_LAYR),SECRET3,SECRET2,SECRET1,SECRET8,SECRET9,_______,_______,_______,_______,_______, DM_REC1, DM_REC2, _______, _______,
        _______,SECRET4,SECRET5, SECRET6, SECRET7, _______, _______, _______, _______, QK_LEAD, KC_SCRL, KC_PSCR,        _______, _______,
        MO(SFT_LAYR),_______,SECRET10,SECRET11,_______,_______,_______,_______, DM_PLY1, DM_PLY2, KC_PAUS, MO(SFT_LAYR), _______, _______,
        _______,   WM_SYM, MO(CTL_LAYR),                  _______,                    MO(CTL_LAYR), _______,    _______, _______, _______
    ),

//  [SFT_LAYR] (yellow/orange)
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |      |    |MyComp||      || Calc || Menu |    |      || Prev || Play || Next |    |      || Mute || Vol- || Vol+ |    | Num  |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  |      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||      ||              ||LLock |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  |          ||      ||      ||      ||      ||      ||      ||  P7  ||  P8  ||  P9  || +  - ||      ||      ||          ||MSRel |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  |             ||      ||      ||      ||      ||      ||      ||  P4  ||  P5  ||  P6  || *  / ||      ||               ||MSHold|  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  |                 ||MSAcl2||      ||      ||      ||      ||      ||  P1  ||  P2  ||  P3  ||      ||           || MSUp || RClk |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  |         ||        || MSAcl0  ||                       P0                     ||   P.    ||   LClk  |  |MSLft || MSDn ||MSRgt |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [SFT_LAYR] = LAYOUT_ansi(
        _______,KC_MYCM, _______, KC_CALC, KC_APP, _______, KC_MPRV, KC_MPLY, KC_MNXT, _______, KC_MUTE, KC_VOLD, KC_VOLU,         KC_NUM,
        _______,_______,_______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, LLOCK,
        _______,_______,_______,_______, _______, _______, _______, KC_P7, KC_P8, KC_P9, DUAL_PLUSMIN, _______, _______, _______,  MK_REL,
        _______,_______,_______,_______,_______, _______, _______, KC_P4, KC_P5, KC_P6, DUAL_MULTDIV, _______,          _______,  MK_HOLD,
        _______,MK_ACCEL2, _______,_______,_______,_______, _______, KC_P1, KC_P2, KC_P3, _______,          _______, KC_MS_UP, KC_MS_BTN2,
        _______,_______, MK_ACCEL0,                      KC_P0,                  KC_PDOT, KC_MS_BTN1, KC_MS_LEFT, KC_MS_DOWN, KC_MS_RIGHT
    ),

//  [CTL_LAYR] (red)
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |      |    |RMode+||RMode-||      ||      |    |RHue+ ||RHue- ||RSat+ ||RSat- |    |      ||      ||ClrTst||Debug |    |RGBTog|  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  | USB  || BT1  || BT2  || BT3  || 2.4G ||      ||      ||      ||      ||      ||      ||      ||      ||              ||LLock |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  |          ||      ||      ||      ||Reboot||      ||      ||      ||      ||      ||      ||      ||      || ChngBase ||      |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  |             ||      ||      ||      ||Flash ||      ||      ||      ||      ||      ||KTrack||FJLite|| HomeRowLight  ||      |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  |                 ||      ||      ||EClear||      ||BootLd||      ||      ||      ||      ||      ||           ||RBri+ ||      |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  |         ||        ||         ||            Battery Level Check               ||         ||         |  |RSpd- ||RBri- ||RSpd+ |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [CTL_LAYR] = LAYOUT_ansi(
        _______, RGB_MOD, RGB_RMOD, _______,_______, RGB_HUI, RGB_HUD, RGB_SAI, RGB_SAD, _______, _______, COLORTEST, DB_TOGG,    RGB_TOG,
        KC_USB, KC_BT1, KC_BT2, KC_BT3, KC_2G4, _______,_______,_______, _______, _______, _______, _______, _______, _______,      LLOCK,
        _______,_______,_______,_______, QK_RBT, _______,_______, _______, _______, _______, _______, _______, _______, BASE_CHG, _______,
        _______,_______,_______,_______, FLASH_KB, _______,_______, _______, _______, _______, KTRACK, FJLIGHT,   HROWLIGHT,      _______,
        _______,_______,_______, EE_CLR, _______, BOOTLDR, _______,_______,_______, _______, _______,           _______, RGB_VAI, _______,
        _______,_______,_______,                          KC_BATQ,                     _______, _______,        RGB_SPD, RGB_VAD, RGB_SPI
    ),

//  [TMUX_LAYR] (cyan)
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |      |    |TLEKY ||TLCMD ||      ||      |    |TMONON||TMONOF||TVISON||TVISOF|    |TJPANE||      ||WINLFT||WINRGT|    |      |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  |      ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||              ||LLock |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  |          ||LTRANS||LTRANS||      ||      ||LTRANS||      ||      ||      ||LTRANS||LTRANS||LTRANS||LTRANS||          ||      |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  |             ||      ||LTRANS||LTRANS||      ||      ||      ||      ||      ||LTRANS||LTRANS||LTRANS||               ||LTRANS|  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  |                 ||LTRANS||LTRANS||LTRANS||      ||      ||LTRANS||      ||LTRANS||LTRANS||LTRANS||           ||LTRANS||      |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  |         ||        ||  LALT   ||                   LTRANS                     ||  LALT   ||         |  |LTRANS||LTRANS||LTRANS|  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [TMUX_LAYR] = LAYOUT_ansi(
        _______, TMUXLKEY, TMUXLCMD, _______, _______,  TMONON, TMONOF, TVISON, TVISOF,  TJPANE, _______, TWINLFT, TWINRGT,   _______,
        _______, LTRANS,LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,     _______,    LLOCK,
        _______,    LTRANS,LTRANS, _______,_______,LTRANS,_______,_______,_______,LTRANS, LTRANS, LTRANS, LTRANS, _______,    _______,
        _______,        _______,LTRANS,LTRANS, _______,_______,_______,_______,_______, LTRANS, LTRANS, LTRANS,     _______,   LTRANS,
        _______,          LTRANS, LTRANS, LTRANS, _______,_______, LTRANS, _______,LTRANS,LTRANS,LTRANS,    _______,  LTRANS, _______,
        _______,    _______,  KC_LALT,                      LTRANS,                      KC_LALT,  _______,  LTRANS,  LTRANS,  LTRANS
    ),

//  [SYMBOL_LAYR] (blue)
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |      |    | SUP1 || SUP2 || SUP3 ||      |    |SUITH ||SUITD ||SUITC ||SUITS |    |      ||      ||      || NBSP |    |      |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  |TD(G) ||TD(O1)||OPT2  ||OPT3  ||OPT4  ||OPT5  ||OPT6  ||OPT7  ||OPT8  ||OPT9  ||OPT0  ||OPTMIN||OPTEQ ||              ||LLock |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  |          ||OPTQ  ||OPTW  ||TD(E) ||OPTR  ||OPTT  ||OPTY  ||TD(U) ||TD(I) ||OPTO  ||OPTP  ||OPTLBR||OPTRBR||OPTBSL    ||      |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  |             ||OPTA  ||OPTS  ||OPTD  ||OPTF  ||OPTG  ||OPTH  ||OPTJ  ||OPTK  ||OPTL  ||OPTSEM||OPTAPO||               ||      |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  |                 ||OPTZ  ||OPTX  ||OPTC  ||OPTV  ||OPTB  ||TD(N) ||OPTM  ||OPTCOM||OPTDOT||OPTSLS||           ||      ||      |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  |         ||        ||         ||                                              ||         ||         |  |      ||      ||      |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [SYMBOL_LAYR] = LAYOUT_ansi(
        _______,     SUP1,   SUP2,   SUP3, _______,     SUITH,  SUITD,  SUITC,  SUITS,     _______, _______, _______, NBSP,     _______,
        TD(ACT_GRV), TD(ACT_1), OPT2, OPT3, OPT4, OPT5,  OPT6,   OPT7,  OPT8,   OPT9,  OPT0,   OPTMIN,  OPTEQ,       _______,     LLOCK,
        _______,    OPTQ,  OPTW, TD(ACT_E), OPTR,  OPTT,   OPTY, TD(ACT_U), TD(ACT_I), OPTO, OPTP,  OPTLBR,  OPTRBR, OPTBSL,    _______,
        _______,        OPTA,  OPTS,  OPTD,  OPTF,   OPTG,     OPTH,   OPTJ,   OPTK,   OPTL,   OPTSEM, OPTAPO,      _______,    _______,
        _______,           OPTZ,  OPTX,  OPTC,   OPTV,   OPTB, TD(ACT_N),  OPTM,   OPTCOM,  OPTDOT, OPTSLS,   _______, _______, _______,
        _______,    _______,  _______,                      _______,                    _______,   _______,   _______, _______, _______
    ),


//  [MAC_SYMBOL_LAYR] (blue)
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |      |    |      ||      ||      ||      |    |      ||      ||      ||      |    |      ||      ||      ||      |    |      |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  |LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||              ||LLock |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  |          ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS    ||      |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  |             ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||               ||      |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  |    LShift       ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||  RShift   ||      ||      |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  |         ||        ||         ||                                              ||         ||         |  |      ||      ||      |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [MAC_SYMBOL_LAYR] = LAYOUT_ansi(
        _______, _______, _______, _______, _______,  _______, _______, _______, _______,  _______, _______, _______, _______,  _______,
        LTRANS,  LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,      _______,    LLOCK,
        _______,     LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS ,LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,    _______,
        _______,         LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,     _______,   _______,
        KC_LSFT,           LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,    KC_RSFT, _______, _______,
        _______,  _______,  _______,                        _______,                      _______,  _______,  _______, _______, _______
    ),

//  [WIDE_TEXT_LAYR] (blue)
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |      |    |      ||      ||      ||      |    |      ||      ||      ||      |    |      ||      ||      ||      |    |      |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  |LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||              ||LLock |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  |          ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS    ||BarTxt|  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  |             ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||               ||SThru |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  |                 ||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||LTRANS||           ||      ||UnderL|  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  |         ||        ||         ||                                              ||         ||         |  |      ||      ||      |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [WIDE_TEXT_LAYR] = LAYOUT_ansi(
        _______, _______, _______, _______, _______,  _______, _______, _______, _______,  _______, _______, _______, _______,  _______,
        LTRANS,  LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,      _______,    LLOCK,
        _______,     LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS ,LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,    BARTEXT,
        _______,         LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,     _______,     STHRU,
        _______,           LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS, LTRANS,    _______, _______, UNDERLN,
        _______,  _______,  _______,                        LTRANS,                      _______,  _______,  _______, _______, _______
    ),

//  [LOCK_LAYR]
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |  No  |    |  No  ||  No  ||  No  ||  No  |    |  No  ||  No  ||  No  ||  No  |    |  No  ||  No  ||  No  ||  No  |    |TDUnlk|  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  |  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||      No      ||  No  |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  |    No    ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||    No    ||  No  |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  |     No      ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||      No       ||  No  |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  |       No        ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||  No  ||    No     ||  No  ||  No  |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  |   No    ||   No   ||   No    ||                      No                      ||   No    ||   No    |  |  No  ||  No  ||  No  |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
    [LOCK_LAYR] = LAYOUT_ansi(
        KC_NO,       KC_NO, KC_NO,  KC_NO,  KC_NO,      KC_NO,  KC_NO,  KC_NO,  KC_NO,      KC_NO,  KC_NO,  KC_NO,  KC_NO,  TD(KB_UNLOCK),
        KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,      KC_NO,       KC_NO,
        KC_NO,       KC_NO, KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,    KC_NO,     KC_NO,
        KC_NO,          KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,       KC_NO,      KC_NO,
        KC_NO,             KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,  KC_NO,     KC_NO,     KC_NO,  KC_NO,
        KC_NO,      KC_NO,    KC_NO,                        KC_NO,                        KC_NO,     KC_NO,      KC_NO,  KC_NO,  KC_NO
    )
};

//  <~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>
//  ~=~=~=~=~=~=~=~=~=~=~=~ LED Indexes ~=~=~=~=~=~=~=~=~=~=~=~
//  ,------------------------------------------------------------------------------------------------------------------------------------,
//  :   ______      ______________________________      ______________________________      ______________________________      ______   :
//  :  |  0   |    |  1   ||  2   ||  3   ||  4   |    |  5   ||  6   ||  7   ||  8   |    |  9   ||  10  ||  11  ||  12  |    |  13  |  :
//  :  |______|    |______||______||______||______|    |______||______||______||______|    |______||______||______||______|    |______|  :
//  :   ______________________________________________________________________________________________________________________________   :
//  :  |  14  ||  15  ||  16  ||  17  ||  18  ||  19  ||  20  ||  21  ||  22  ||  23  ||  24  ||  25  ||  26  ||      27      ||  28  |  :
//  :  |______||______||______||______||______||______||______||______||______||______||______||______||______||______________||______|  :
//  :  |    29    ||  30  ||  31  ||  32  ||  33  ||  34  ||  35  ||  36  ||  37  ||  38  ||  39  ||  40  ||  41  ||    42    ||  43  |  :
//  :  |__________||______||______||______||______||______||______||______||______||______||______||______||______||__________||______|  :
//  :  |     44      ||  45  ||  46  ||  47  ||  48  ||  49  ||  50  ||  51  ||  52  ||  53  ||  54  ||  55  ||      56       ||  57  |  :
//  :  |_____________||______||______||______||______||______||______||______||______||______||______||______||_______________||______|  :
//  :  |       58        ||  59  ||  60  ||  61  ||  62  ||  63  ||  64  ||  65  ||  66  ||  67  ||  68  ||    69     ||  70  ||  71  |  :
//  :  |_________________||______||______||______||______||______||______||______||______||______||______||___________||______||______|  :
//  :  |   72    ||   73   ||   74    ||                      75                      ||   76    ||   77    |  |  78  ||  79  ||  80  |  :
//  :  |_________||________||_________||______________________________________________||_________||_________|  |______||______||______|  :
//  `------------------------------------------------------------------------------------------------------------------------------------`
// useful key indexes
enum key_indexes {
    I_INDICATOR = 0,
    I_ESC = 0,
    I_NUMLOCK = 13,
    I_GRV = 14,
    I_1 = 15,
    I_2 = 16,
    I_3 = 17,
    I_4 = 18,
    I_5 = 19,
    I_6 = 20,
    I_7 = 21,
    I_8 = 22,
    I_9 = 23,
    I_0 = 24,    
    I_MIN = 25,
    I_PLUS = 26,
    I_HOME = 28,
    I_LLOCK = 28,
    I_TAB = 29,
    I_Q = 30,
    I_W = 31,
    I_E = 32,
    I_R = 33,
    I_T = 34,
    I_Y = 35,
    I_U = 36,
    I_I = 37,
    I_O = 38,
    I_P = 39,
    I_MREC1 = 40,
    I_MREC2 = 41,
    I_ENDPGUP = 43,
    I_BARTEXT = 43,
    I_CAPS = 44,
    I_A = 45,
    I_S = 46,
    I_D = 47,
    I_F = 48,
    I_G = 49,
    I_H = 50,
    I_J = 51,
    I_K = 52,
    I_L = 53,
    I_SEMI = 54,
    I_SLOCK = 54,
    I_FJLIGHT = 55,
    I_HROWLIGHT = 56,
    I_PGUPPGDN = 57,
    I_STHRU = 57,
    I_LSFT = 58,
    I_Z = 59,
    I_X = 60,
    I_C = 61,
    I_V = 62,
    I_B = 63,
    I_N = 64,
    I_M = 65,
    I_COMMA = 66,
    I_MPLY1 = 66,
    I_MPLY2 = 67,
    I_DOT = 67,
    I_RSFT = 69,
    I_UP = 70,
    I_PGDNEND = 71,
    I_UNDERLN = 71,
    I_LCTL = 72,
    I_LGUI = 73,
    I_LOPT = 73,
    I_LALT = 74,
    I_LCMD = 74,
    I_RALT = 76,
    I_RCMD = 76,
    I_FN = 77,
    I_LEFT = 78,
    I_DOWN = 79,
    I_RIGHT = 80
};

// led indexes for keys that get capitalized when caps lock is on
bool is_capslock_shifted(uint8_t i) {
    if ((i > 29 && i < 40) || (i > 44 && i < 54) || (i > 58 && i < 66)) {
        return true;
    }
    return false;
}
// led indexes for keys that get shifted when caps word is on
bool is_capsword_shifted(uint8_t i) {
    if (i == 25 || is_capslock_shifted(i)) {
        return true;
    }
    return false;
}

// tap dance setup
typedef struct {
    bool is_press_action;
    int state;
} tap;
// tap dance states
enum {
    SINGLE_TAP = 1,
    SINGLE_HOLD = 2,
    DOUBLE_TAP = 3,
    DOUBLE_HOLD = 4,
    TRIPLE_TAP = 5,
    QUAD_TAP = 6,
    PENT_TAP = 7,
    HEXA_TAP = 8
};
// functions associated with all tap dances
int cur_dance (tap_dance_state_t *state);
// functions associated with individual tap dances
void caps_finished (tap_dance_state_t *state, void *user_data);
void caps_reset (tap_dance_state_t *state, void *user_data);
void ralt_finished (tap_dance_state_t *state, void *user_data);
void ralt_reset (tap_dance_state_t *state, void *user_data);
void fn_finished (tap_dance_state_t *state, void *user_data);
void fn_reset (tap_dance_state_t *state, void *user_data);
void rsft_finished (tap_dance_state_t *state, void *user_data);
void rsft_reset (tap_dance_state_t *state, void *user_data);
void kbunlock_finished (tap_dance_state_t *state, void *user_data);
void kbunlock_reset (tap_dance_state_t *state, void *user_data);
void actgrv_finished (tap_dance_state_t *state, void *user_data);
void actgrv_reset (tap_dance_state_t *state, void *user_data);
void act1_finished (tap_dance_state_t *state, void *user_data);
void act1_reset (tap_dance_state_t *state, void *user_data);
void acte_finished (tap_dance_state_t *state, void *user_data);
void acte_reset (tap_dance_state_t *state, void *user_data);
void actu_finished (tap_dance_state_t *state, void *user_data);
void actu_reset (tap_dance_state_t *state, void *user_data);
void acti_finished (tap_dance_state_t *state, void *user_data);
void acti_reset (tap_dance_state_t *state, void *user_data);
void actn_finished (tap_dance_state_t *state, void *user_data);
void actn_reset (tap_dance_state_t *state, void *user_data);
void lgui_finished (tap_dance_state_t *state, void *user_data);
void lgui_reset (tap_dance_state_t *state, void *user_data);
void rcmd_finished (tap_dance_state_t *state, void *user_data);
void rcmd_reset (tap_dance_state_t *state, void *user_data);
void lopt_finished (tap_dance_state_t *state, void *user_data);
void lopt_reset (tap_dance_state_t *state, void *user_data);

// key tracker
typedef struct {
    uint8_t index;
    bool press;
    int fade;
} keytracker;

// function for determining if a key should fade
bool key_should_fade(keytracker key, uint8_t layer);

// setup keytracker
static deferred_token key_token = INVALID_DEFERRED_TOKEN;
static keytracker tracked_keys[20];
static int tk_length = sizeof(tracked_keys) / sizeof(tracked_keys[0]);

// for tracking if leader sequence is started
bool is_in_leader_sequence;
bool is_leader_led_on;
static uint16_t leader_timer;
bool is_leader_error;
bool is_leader_error_led_on;
static uint16_t leader_error_timer;

// setup a way to delay oneshot deactivation after a keycode that keeps oneshot active
// a one-shot extended time can be simulated by simply turning a layer on and using the
// callback to turn the layer off after a specified delay
bool sim_osl;
static deferred_token sim_osl_token = INVALID_DEFERRED_TOKEN;
uint32_t sim_osl_callback(uint32_t trigger_time, void* cb_arg) {
    dprintf("sim_osl_callback running\n");
    uint8_t layer = get_highest_layer(layer_state);
    if (!is_layer_locked(layer)) {
        layer_off(layer);
    }
    sim_osl = false;
    return 0;
}

// if a leader seuqence errored, rgbs can be set to blink for a time until this callback is used 
static deferred_token leader_error_token = INVALID_DEFERRED_TOKEN;
uint32_t leader_error_callback(uint32_t trigger_time, void* cb_arg) {
    is_leader_error = false;
    is_leader_error_led_on = false;
    return 0;
}

// for tracking whether to highlight home row keys f and j
bool fj_light;
// and for tracking if the full home row light is on
bool hrow_light;
// for disabling the keytracker, which will also disable key-reactive fade
bool enable_keytracker = true;

// for tracking whether to blink an led as an indicator, used to show which layer is active
bool is_led_on;
static uint16_t layer_timer;

// for tracking layer lock in order to flash the layer lock indicator
bool is_layer_lock_led_on;
static uint16_t layer_lock_timer;

// for tracking key lock blinking
bool is_key_lock_led_on;
static uint16_t key_lock_timer;

// for tracking a recording macro
int8_t macro_direction;
bool macro_recording;
bool is_macro_led_on;
static uint16_t macro_timer;
// and a delayed callback after playing a dynamic macro from osl
static deferred_token osl_macro_token = INVALID_DEFERRED_TOKEN;
// callback for when a dynamic mcaro on fn osl is run (to turn off the layer)
uint32_t osl_macro_callback(uint32_t trigger_time, void *cb_arg) {
    layer_off(FN_LAYR);
    return 0;
}

// funciton to send an alternate key if a modifier is being held
void dual_key(uint16_t std_keycode, uint16_t alt_keycode, uint8_t mod_mask);

// function to send symbols normally requiring alt codes in ms windows
void symbol_key(const char *alt_code, const char *shift_alt_code);
// and to type a string of numbers using the numpad (created for windows alt codes)
void type_numpad_keys_from_string(const char *stringnum);

// for tracking if oneshot layer is active
bool oneshot_layer_active;

// for tracking if a wireless indicator should show on any layer
// this gets set and elapsed time is tracked after a wireless or battery keycode is used
uint32_t wls_action_timer;

// if rgb color-test is requested, set this bool
bool color_test;
// and use a timer so that it can be turned off after a delay even if no further key is pressed
static uint16_t color_test_timer;

// for tracking if the base layer was changed in order to flash some indicators
bool base_layer_changed;
static uint16_t base_change_timer;
bool macwin_changed;
static uint16_t macwin_change_timer;

// for tracking if an accent char tap dance should light up a particular key to show what the tap will send
int act_char_led_index = 0;

// for tracking if base is win or mac
bool is_mac_base(void) {
    return (IS_LAYER_ON(MAC_BASE2_LAYR) || IS_LAYER_ON(MAC_BASE_LAYR)); 
}
// use this to highlight keyboard shortcuts with rgb when winkey is held
// split some of these into another color since they are used rarely
bool is_winkey_held;
int winkey_scut_keys[] = {I_INDICATOR, I_0, I_1, I_2, I_3, I_4, I_5, I_6, I_7, I_8, I_9, I_TAB, I_Q, I_E, I_R, I_A, I_D, I_L,
                          I_X, I_B, I_N, I_LEFT, I_RIGHT, I_UP, I_DOWN};
int winkey_scut_altcolor[] = {I_MIN, I_PLUS, I_T, I_U, I_I, I_P, I_S, I_F, I_G, I_H, I_K, I_SEMI, I_Z, I_V, I_M, I_COMMA, I_DOT};
int winkey_scut_keys_size = sizeof(winkey_scut_keys) / sizeof(winkey_scut_keys[0]);
int winkey_scut_altcolor_size = sizeof(winkey_scut_altcolor) / sizeof(winkey_scut_altcolor[0]);

// for tracking wide-text options for the WIDE_TEXT_LAYR
bool wide_sthru = false;
bool wide_underln = false;
bool wide_bartext = false;
bool wide_firstchar = false;

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    static uint32_t key_timer;
    // stop color test if active and a key is pressed
    if (color_test && record->event.pressed) {
        color_test = false;
        return false;
    }
    // record key index pressed for rgb reactive changes
    if (enable_keytracker && !is_macro_playing) {
        int key_idx = g_led_config.matrix_co[record->event.key.row][record->event.key.col];
        if (record->event.pressed) {
            dprintf("%u \n", key_idx);
            for (int i = tk_length - 1; i > 0; i--) {
                tracked_keys[i] = tracked_keys[i-1];
                if (tracked_keys[i].index == key_idx) {
                    tracked_keys[i].press = true;
                    tracked_keys[i].fade = 255;
                }
            }
            tracked_keys[0].press = true;
            tracked_keys[0].fade = 255;
            tracked_keys[0].index = key_idx;
        }
        else {
            for (int i = 0; i < tk_length; i++) {
                if (tracked_keys[i].index == key_idx) {
                    tracked_keys[i].press = false;
                    tracked_keys[i].fade = 119;
                }
            }
            // setup the key fade
            if (key_token) {
                cancel_deferred_exec(key_token);
                key_token = INVALID_DEFERRED_TOKEN;
            }
            uint32_t keytracker_callback(uint32_t trigger_time, void* cb_arg) {
                bool fade_changed = false;
                for (int i = 0; i < tk_length; i++) {
                    if (!tracked_keys[i].press && tracked_keys[i].fade > 0) {
                        tracked_keys[i].fade--;
                        fade_changed = true;
                    }
                }
                if (fade_changed) {
                    return 12;  // Call the callback every 12ms
                }
                else {
                    return 0;
                }
            }
            key_token = defer_exec(10, keytracker_callback, NULL);  // Schedule callback.
        }
    }
    // layer lock
    if (!process_layer_lock(keycode, record, LLOCK)) {
       return false;
    }

    switch (keycode) {
    // this is a custom version of KC_TRANS to press a key on default layer
    // setup so that I can use LTRANS in the keymap to denote which fallthrough keys get lit up on the layer
    case LTRANS:
        if (record->event.pressed) {
            uint8_t layer = get_highest_layer(layer_state);
            const uint8_t mods = get_mods();
            // prefix to send for the TMUX_LAYR
            if (layer == TMUX_LAYR) {
                unregister_mods(mods); // temp remove mods
                tap_code16(C(KC_B));   // send ctrl-b before keycode processing
                register_mods(mods);   // reapply mods
            }
            // hold option for MAC_SYMBOL_LAYR
            else if (layer == MAC_SYMBOL_LAYR) {
                register_code(KC_LOPT);
            }
            // for some wide modes, should start with the spacing char
            if (layer == WIDE_TEXT_LAYR && wide_firstchar) {
                unregister_mods(mods); // temp remove mods 
                if (wide_bartext) {
                    tap_code16(KC_PIPE);
                }
                else if (wide_sthru) {
                    tap_code16(KC_MINS);
                }
                else if (wide_underln) {
                    tap_code16(KC_UNDS);
                }
                register_mods(mods);   // reapply mods
                wide_firstchar = false;
            }
            // send keydown from the default layer
            register_code(keymap_key_to_keycode(biton32(default_layer_state), record->event.key));
            // release option for MAC_SYMBOL_LAYR
            if (layer == MAC_SYMBOL_LAYR) {
                unregister_code(KC_LOPT);
            }
            // if WIDE_TEXT_LAYER, add the extra spacing char
            else if (layer == WIDE_TEXT_LAYR) {
                unregister_mods(mods); // temp remove mods 
                if (wide_bartext) {
                    tap_code16(KC_PIPE);
                }
                else if (wide_sthru) {
                    tap_code16(KC_MINS);
                }
                else if (wide_underln) {
                    tap_code16(KC_UNDS);
                }
                else {
                    tap_code16(KC_SPC);
                }
                register_mods(mods);   // reapply mods
            }
        }
        else {
            unregister_code(keymap_key_to_keycode(biton32(default_layer_state), record->event.key));
        }
        return false;
        break;
    // tmux bound key list
    case TMUXLKEY:
        if (record->event.pressed) {
           //send_string(SS_LCTL("b") ":list-keys" SS_TAP(X_ENT));
           send_string(SS_LCTL("b") "?");
        }
        break;
    // tmux command list
    case TMUXLCMD:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("list-commands\n");
        }
        break;
    // tmux monitor window activity on 
    case TMONON:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("setw monitor-activity on\n");
        }
        break;
    // tmux monitor window activity off
    case TMONOF:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("setw monitor-activity off\n");
        }
        break;
    // tmux visual activity alerts on
    case TVISON:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("setw -g visual-activity on\n");
        }
        break;
    // tmux visual activity alerts off
    case TVISOF:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("setw -g visual-activity off\n");
        }
        break;
    // tmux move window left 1 position
    case TWINLFT:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("swap-window -t -1\n");
           send_string_with_delay(SS_LCTL("b") "p",10);
        }
        break;
    // tmux move window right 1 position
    case TWINRGT:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("swap-window -t +1\n");
           send_string_with_delay(SS_LCTL("b") "n",10);
        }
        break;
    case TJPANE:
        if (record->event.pressed) {
           send_string_with_delay(SS_LCTL("b") ":",10);
           send_string("join-pane -t" SS_TAP(X_SPACE));
        }
        break;
    case WAVE:  // Types ~=~=~=~=~=~ or <~>~<~>~<~>~<~>
        static deferred_token wave_token = INVALID_DEFERRED_TOKEN;
        static uint8_t wave_phase = 0;
        if (!record->event.pressed) {  // On release.
            const uint8_t mods = get_mods();
            cancel_deferred_exec(wave_token);
            wave_token = INVALID_DEFERRED_TOKEN;
            // ensure the pattern always ends on a ">"
            if (mods & MOD_MASK_CTRL) {  // Is ctl held?
                unregister_mods(MOD_MASK_CTRL); // temp remove ctl
                if ((wave_phase & 1) == 0) {
                    send_string("<~>");
                }
                else {
                    tap_code16(KC_RABK);
                }
                register_mods(mods);           // restore mods
            }
            else {
                if ((wave_phase & 1) == 0) { tap_code16(KC_TILD); }
            }
            wave_phase = 0;
        }
        else if (!wave_token) {  // on press
            uint32_t wave_callback(uint32_t trigger_time, void* cb_arg) {
                const uint8_t mods = get_mods();
                const uint8_t oneshot_mods = get_oneshot_mods();
                if ((mods | oneshot_mods) & MOD_MASK_CTRL) {  // is ctl held?
                    del_oneshot_mods(MOD_MASK_CTRL); // remove ctl
                    unregister_mods(MOD_MASK_CTRL);  // remove ctl
                    tap_code16((++wave_phase & 1) ? KC_LABK : KC_RABK);
                    tap_code16(KC_TILD);
                    register_mods(mods);            // restore mods
                }
                else {
                    tap_code16((++wave_phase & 1) ? KC_TILD : KC_EQL);
                }
                return 16;  // call the callback every 16 ms
            }
            wave_token = defer_exec(1, wave_callback, NULL);
        }
        return false;
        break;
    case ARROW:
        if (record->event.pressed) {
            const uint8_t mods = get_mods();
            const uint8_t oneshot_mods = get_oneshot_mods();
            if ((mods | oneshot_mods) & MOD_MASK_CTRL) {  // is ctl held?
                // Temporarily delete cmd.
                del_oneshot_mods(MOD_MASK_CTRL);
                unregister_mods(MOD_MASK_CTRL);
                SEND_STRING("=>");
                register_mods(mods);            // restore mods
                return false;
            } else {
                SEND_STRING("->");
            }
        }
        break;

    case BSPCFAST:  // backspace with exponential repeating
        // initial delay before the first repeat
        static const uint8_t INIT_DELAY_MS = 250;
        // This array customizes the rate at which the Backspace key
        // repeats. The delay after the ith repeat is REP_DELAY_MS[i].
        // Values must be between 1 and 255.
        static const uint8_t REP_DELAY_MS[] PROGMEM = {
            99, 79, 65, 57, 49, 43, 40, 35, 33, 30, 28, 26, 25, 23, 22, 20,
            20, 19, 18, 17, 16, 15, 15, 14, 14, 13, 13, 12, 12, 11, 11, 10};
        static deferred_token bspc_token = INVALID_DEFERRED_TOKEN;
        static uint8_t rep_count = 0;
        if (!record->event.pressed) {  // Backspace released: stop repeating
            cancel_deferred_exec(bspc_token);
            bspc_token = INVALID_DEFERRED_TOKEN;
        }
        else if (!bspc_token) {  // Backspace pressed: start repeating
            tap_code(KC_BSPC);  // Initial tap of Backspace key
            rep_count = 0;
            uint32_t bspc_callback(uint32_t trigger_time, void* cb_arg) {
              tap_code(KC_BSPC);
              if (rep_count < sizeof(REP_DELAY_MS)) { ++rep_count; }
              return pgm_read_byte(REP_DELAY_MS - 1 + rep_count);
            }
            bspc_token = defer_exec(INIT_DELAY_MS, bspc_callback, NULL);
        }
        break;
    // get dynamic macros to work even with oneshot layers
    case DM_REC1:
    case DM_REC2:
    case DM_PLY1:
    case DM_PLY2:
        if (record->event.pressed) {
            if (oneshot_layer_active) {
                reset_oneshot_layer();
                osl_macro_token = defer_exec(100, osl_macro_callback, NULL);
            }
        }
        break;
    case DUAL_PLUSMIN:
        if (record->event.pressed) {
            // standard: plus symbol, while control is held: minus
            dual_key(KC_PPLS, KC_PMNS, MOD_MASK_CTRL);
        }
        break;
    case DUAL_MULTDIV:
        if (record->event.pressed) {
            // standard: asterisk, while control is held: divide
            dual_key(KC_PAST, KC_PSLS, MOD_MASK_CTRL);
        }
        break;
    case DUAL_ESC:
        if (record->event.pressed) {
           if (!macro_recording) {
               // send escapse
               register_code(KC_ESC);
           }
           else {
               // if macro is recording, stop it
               dynamic_macro_stop_recording();
           }
        }
        else {
            unregister_code(KC_ESC);
        }
        break;
    // this is setup so I can use F12 key to insert a delay while recording a macro
    case DUAL_F12:
        if (record->event.pressed) {
           if (!macro_recording && !is_macro_playing) { 
               // send F12 
               register_code(KC_F12);
           }
           else {
               // if macro is recording or playing, insert a delay
               // wait_ms(150); // this only works when wired
               send_string(SS_DELAY(150)); // this works wired and wireless
           }
        }
        else {
           if (!macro_recording && !is_macro_playing) {
               unregister_code(KC_F12);
           }
        }
        break; 
    case VI_REPLACE:
        if (record->event.pressed) {
           // start syntax for vi search and replace
           send_string(":%s///g" SS_TAP(X_LEFT) SS_TAP(X_LEFT) SS_TAP(X_LEFT));
        }
        break;
    case GIT_ADD:
        if (record->event.pressed) {
           // add updates to git commit
           send_string("git add -A" SS_TAP(X_ENT));
        }
        break;
    case GIT_COMMIT:
        if (record->event.pressed) {
           // commit changes
           send_string("git commit -m \"\"" SS_TAP(X_LEFT));
        }
        break;
    case GIT_PUSH:
        if (record->event.pressed) {
           // push commit to git repo
           send_string("git push" SS_TAP(X_ENT));
        }
        break;
    case GIT_CHKOUT:
        if (record->event.pressed) {
           // checkout last commit from git repo
           send_string("git checkout ." SS_TAP(X_ENT));
        }
        break;
    case GIT_LOG:
        if (record->event.pressed) {
           // show the git log
           send_string("git log" SS_TAP(X_ENT));
        }
        break;
    // volume up and down should be able to be pressed multiple times without cancelling a oneshot layer
    case KC_VOLD:
    case KC_VOLU:
        if (oneshot_layer_active || sim_osl) {
          reset_oneshot_layer();
          if (sim_osl_token) {
              cancel_deferred_exec(sim_osl_token);
              sim_osl_token = INVALID_DEFERRED_TOKEN;
          }
          if (record->event.pressed) {
              sim_osl = true;
              uint8_t layer = get_highest_layer(layer_state);
              layer_on(layer); // simulate that oneshot is still going
          }
          else {   // key release should use a delay for layer deactivation
              // this turns off the layer if further volume controls are not used within 500ms
              sim_osl_token = defer_exec(500, sim_osl_callback, NULL);
          }
        }
        break;
    case FJLIGHT:
    	if (record->event.pressed) {
	   // update the var used for f and j home key highlighting 
	   fj_light = !fj_light;
	}
    	break;
    case HROWLIGHT:
    	if (record->event.pressed) {
	   // update the var used for full home row keys highlighting 
	   hrow_light = !hrow_light;
	}
    	break;
    case KTRACK:
        if (record->event.pressed) {
           // update the var used to enable/disable keytracker and per-key fade
           enable_keytracker = !enable_keytracker;
        }
        break;
    case BASE_CHG:
        if (record->event.pressed) {
            int b_layer = is_mac_base() ? MAC_BASE_LAYR : BASE_LAYR;
            int b2_layer = is_mac_base() ? MAC_BASE2_LAYR : BASE2_LAYR;
            if (IS_LAYER_ON(b_layer))
            {
                set_single_persistent_default_layer(b2_layer);
                layer_move(b2_layer);
            }
            else
            {
                set_single_persistent_default_layer(b_layer);
                layer_move(b_layer);
            }
            base_layer_changed = true;
            return false;
        }
        break;
    case MK_HOLD:
    	if (record->event.pressed) {
    	   register_code(KC_MS_BTN1);
        }
        break;
    case MK_REL:
    	if (record->event.pressed) {
    	   unregister_code(KC_MS_BTN1);
        }
        break;
    case MK_ACCEL0:
        tap_code(record->event.pressed ? KC_MS_ACCEL0 : KC_MS_ACCEL1);
        break;
    case MK_ACCEL2:
        tap_code(record->event.pressed ? KC_MS_ACCEL2 : KC_MS_ACCEL1);
        break;
    case WM_SYM:
        if (record->event.pressed) {
            if (is_mac_base()) {
                layer_on(MAC_SYMBOL_LAYR);
            }
            else {
                layer_on(SYMBOL_LAYR);
            }
        }
        else {
            if (is_mac_base()) {
                if (!is_layer_locked(MAC_SYMBOL_LAYR)) {
                    layer_off(MAC_SYMBOL_LAYR);
                }
            }
            else {
                if (!is_layer_locked(SYMBOL_LAYR)) { 
                    layer_off(SYMBOL_LAYR);
                }
            }
        } 
        break;
    case COLORTEST:
        if (record->event.pressed) {
            color_test_timer = timer_read();
            color_test = true;
        }
        break;
    // the following OPT keycodes mimic a macos option os layer for symbols and accents
    // symbol_key() is a fn to type a windows alt code on the numpad
    case OPT2:
        if (record->event.pressed) {
            symbol_key("0153","0128");
        }   
        break;
    case OPT3:
        if (record->event.pressed) {
            symbol_key("156","0139");
        }   
        break;
    case OPT4:
        if (record->event.pressed) {
            symbol_key("155","0155");
        }   
        break;
    case OPT5:
        if (record->event.pressed) {
            symbol_key("236","64257");
        }   
        break;
    case OPT6:
        if (record->event.pressed) {
            symbol_key("21","64258");
        }   
        break;
    case OPT7:
        if (record->event.pressed) {
            symbol_key("20","0135");
        }   
        break;
    case OPT8:
        if (record->event.pressed) {
            symbol_key("7","248");
        }   
        break;
    case OPT9:
        if (record->event.pressed) {
            symbol_key("166","9");
        }   
        break;
    case OPT0:
        if (record->event.pressed) {
            symbol_key("167","0164");
        }   
        break;
    case OPTMIN:
        if (record->event.pressed) {
            symbol_key("0151","22");
        }   
        break;
    case OPTEQ:
        if (record->event.pressed) {
            symbol_key("8800","241");
        }   
        break;
    case OPTQ:
        if (record->event.pressed) {
            symbol_key("0156","0140");
        }   
        break;
    case OPTW:
        if (record->event.pressed) {
            symbol_key("228","0132");
        }   
        break;
    case OPTR:
        if (record->event.pressed) {
            symbol_key("0174","0137");
        }   
        break;
    case OPTT:
        if (record->event.pressed) {
            symbol_key("0134","259");
        }   
        break;
    case OPTY:
        if (record->event.pressed) {
            symbol_key("157","0193");
        }   
        break;
    case OPTO:
        if (record->event.pressed) {
            symbol_key("0248","0216");
        }   
        break;
    case OPTP:
        if (record->event.pressed) {
            symbol_key("227","928");
        }   
        break;
    case OPTLBR:
        if (record->event.pressed) {
            symbol_key("0147","0148");
        }   
        break;
    case OPTRBR:
        if (record->event.pressed) {
            symbol_key("0145","0146");
        }   
        break;
    case OPTBSL:
        if (record->event.pressed) {
            symbol_key("174","175");
        }   
        break;
    case OPTA:
        if (record->event.pressed) {
            symbol_key("0229","0197");
        }   
        break;
    case OPTS:
        if (record->event.pressed) {
            symbol_key("225","0205");
        }   
        break;
    case OPTD:
        if (record->event.pressed) {
            symbol_key("8706","0206");
        }   
        break;
    case OPTF:
        if (record->event.pressed) {
            symbol_key("159","0207");
        }   
        break;
    case OPTG:
        if (record->event.pressed) {
            symbol_key("0169","0180");
        }   
        break;
    case OPTH:
        if (record->event.pressed) {
            symbol_key("0183","0211");
        }
        break;
    case OPTK:
        if (record->event.pressed) {
            symbol_key("0186","0208");
        }
        break;
    case OPTJ:
        if (record->event.pressed) {
            symbol_key("30","0212");
        }
        break;
    case OPTL:
        if (record->event.pressed) {
            symbol_key("170","0210");
        }
        break;
    case OPTSEM:
        if (record->event.pressed) {
            symbol_key("0133","0218");
        }
        break;
    case OPTAPO:
        if (record->event.pressed) {
            symbol_key("0230","0198");
        }
        break;
    case OPTZ:
        if (record->event.pressed) {
            symbol_key("234","0184");
        }
        break;
    case OPTX:
        if (record->event.pressed) {
            symbol_key("247","0215");
        }
        break;
    case OPTC:
        if (record->event.pressed) {
            symbol_key("0231","0199");
        }
        break;
    case OPTV:
        if (record->event.pressed) {
            symbol_key("251","4");
        }
        break;
    case OPTB:
        if (record->event.pressed) {
            symbol_key("8747","0305");
        }
        break;
    case OPTM:
        if (record->event.pressed) {
            symbol_key("230","0194");
        }
        break;
    case OPTCOM:
        if (record->event.pressed) {
            symbol_key("243","0175");
        }
        break;
    case OPTDOT:
        if (record->event.pressed) {
            symbol_key("242","0168");
        }
        break;
    case OPTSLS:
        if (record->event.pressed) {
            symbol_key("0247","168");
        }
        break;
    case SUITH:
        if (record->event.pressed) {
            symbol_key("3","3");
        }
        break;
    case SUITD:
        if (record->event.pressed) {
            symbol_key("4","4");
        }
        break;
    case SUITC:
        if (record->event.pressed) {
            symbol_key("5","5");
        }
        break;
    case SUITS:
        if (record->event.pressed) {
            symbol_key("6","6");
        }
        break;
    case SUP1:
        if (record->event.pressed) {
            symbol_key("0185","0185");
        }
        break;
    case SUP2:
        if (record->event.pressed) {
            symbol_key("0178","0178");
        }
        break;
    case SUP3:
        if (record->event.pressed) {
            symbol_key("0179","0179");
        }
        break;
    case NBSP:
        if (record->event.pressed) {
            symbol_key("0160","0166");
        }
        break;
    case STHRU:
        if (record->event.pressed) {
            if (wide_sthru) {
                wide_sthru = false;
                wide_firstchar = false;
            }
            else {
                wide_bartext = false;
                wide_sthru = true;
                wide_underln = false;
                wide_firstchar = true;
            }
        }
        break;
    case UNDERLN:
        if (record->event.pressed) {
            if (wide_underln) {
                wide_underln = false;
                wide_firstchar = false;
            }
            else {
                wide_bartext = false;
                wide_sthru = false;
                wide_underln = true;
                wide_firstchar = true;
            }
        }
        break;
    case BARTEXT:
        if (record->event.pressed) {
            if (wide_bartext) {
                wide_bartext = false;
                wide_firstchar = false;
            }
            else {
                wide_bartext = true;
                wide_sthru = false;
                wide_underln = false;
                wide_firstchar = true;
            }
        }
        break;
    case FLASH_KB:
        if (record->event.pressed) {
           // command to flash this keyboard
           send_string("qmk flash -kb shortcut/bridge75 -km djcastaldo\n");
        }
        break;
    case BOOTLDR:
        if (record->event.pressed) {
            key_timer = timer_read32();
        } else if (timer_elapsed32(key_timer) >= 500) {
            reset_keyboard();
        }
        break;
    // these keycodes should start a timer to allow showing of indicators setup in bridge75.c
    case KC_USB:
    case KC_BT1:
    case KC_BT2:
    case KC_BT3:
    case KC_2G4:
    case KC_BATQ:
         if (record->event.pressed) {
            wls_action_timer = timer_read32();
         }
         break;
    }
    return process_record_secrets(keycode, record);
}

void dual_key(uint16_t std_keycode, uint16_t alt_keycode, uint8_t mod_mask) {
    // if mod is being held, send mod_keycode
    // get current mod states
    const uint8_t mods = get_mods();
    if (mods & mod_mask) {
        unregister_mods(mod_mask);  // remove mod
        tap_code16(alt_keycode);
        register_mods(mods); // restore original mods
    }
    // otherwise send std_keycode
    else {
        tap_code16(std_keycode);
    }
}

void symbol_key(const char *alt_code, const char *shift_alt_code) {
    // get current mod and one-shot mod states.
    const uint8_t mods = get_mods();
    const uint8_t oneshot_mods = get_oneshot_mods();
    bool numlockChanged; // this numlock stuff lets this work in all scenarios 
    numlockChanged = false;
    if ((mods | oneshot_mods) & MOD_MASK_SHIFT) { // if shift is being held
        if (shift_alt_code == NULL || *shift_alt_code == '\0') { // null or empty string
            return;
        }
        // this is needed because tap dances don't correctly unregister shift
        if (host_keyboard_led_state().num_lock) {
             tap_code(KC_NUM);
             numlockChanged = true;
        }
        dprintf("alt hold\n");
        register_code(KC_LALT); // hold down alt
        type_numpad_keys_from_string(shift_alt_code); // send to fn to type numpad keys
        dprintf("alt release\n");
        unregister_code(KC_LALT); // release alt
    } else {
        if (alt_code == NULL || *alt_code == '\0') { // null or empty string
            return;
        }
        if (!host_keyboard_led_state().num_lock) {
             tap_code(KC_NUM);
             numlockChanged = true;
        }
        dprintf("alt hold\n");
        register_code(KC_LALT); // hold down alt
        type_numpad_keys_from_string(alt_code); // send to fn to type numpad keys
        dprintf("alt release\n");
        unregister_code(KC_LALT); // release alt
    }
    if (numlockChanged) {
        tap_code(KC_NUM);
    }
}

// send_string doesn't use the numpad, so this fn was created to type numbers using the numpad
void type_numpad_keys_from_string(const char *stringnum) {
    // now need to loop through each char in the char pointer until a null terminator
    const char *ptr = stringnum;
    while (*ptr != '\0') {
        switch (*ptr) {
        case '0':
            dprintf("0 tap\n");
            tap_code(KC_P0);
            break;
        case '1':
            dprintf("1 tap\n");
            tap_code(KC_P1);
            break;
        case '2':
            dprintf("2 tap\n");
            tap_code(KC_P2);
            break;
        case '3':
            dprintf("3 tap\n");
            tap_code(KC_P3);
            break;
        case '4':
            dprintf("4 tap\n");
            tap_code(KC_P4);
            break;
        case '5':
            dprintf("5 tap\n");
            tap_code(KC_P5);
            break;
        case '6':
            dprintf("6 tap\n");
            tap_code(KC_P6);
            break;
        case '7':
            dprintf("7 tap\n");
            tap_code(KC_P7);
            break;
        case '8':
            dprintf("8 tap\n");
            tap_code(KC_P8);
            break;
        case '9':
            dprintf("9 tap\n");
            tap_code(KC_P9);
            break;
        default:
            dprintf("no number\n");
            break;
        }
    ptr++;
    }   
}

bool rgb_matrix_indicators_advanced_user(uint8_t led_min, uint8_t led_max) {
    uint8_t layer = get_highest_layer(layer_state);
    // color an indicator 
    switch (layer) {
    case FN_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_GREEN);
        break;
    case SFT_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_ORANGE);
        break;
    case CTL_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_RED);
        break;
    case TMUX_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_CYAN);
        break;
    case SYMBOL_LAYR:
    case MAC_SYMBOL_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_BLUE);
        break;
    case WIDE_TEXT_LAYR:
        rgb_matrix_set_color(I_INDICATOR, RGB_YELLOW);
        break;
    case LOCK_LAYR:
        break;
    default:
        break;
    }
    if (layer > 3) {
        for (uint8_t row = 0; row < MATRIX_ROWS; ++row) {
            for (uint8_t col = 0; col < MATRIX_COLS; ++col) {
                uint8_t index = g_led_config.matrix_co[row][col];
    
                if (index >= led_min && index < led_max && index != NO_LED &&
                keymap_key_to_keycode(layer, (keypos_t){col,row}) > KC_TRNS) {
                    switch (layer) {
                    case FN_LAYR:
                        if (index == I_MREC1 || index == I_MREC2) { // macro recording keys
                            rgb_matrix_set_color(index, RGB_MAGENTA);
                        }
                        else {
                            rgb_matrix_set_color(index, RGB_GREEN);
                        }
                        break;
                    case SFT_LAYR:
                        rgb_matrix_set_color(index, RGB_ORANGE);
                        break;
                    case CTL_LAYR:
                        rgb_matrix_set_color(index, RGB_RED);
                        break;
                    case TMUX_LAYR:
                        rgb_matrix_set_color(index, RGB_CYAN);
                        break;
                    case SYMBOL_LAYR:
                    case MAC_SYMBOL_LAYR:
                        rgb_matrix_set_color(index, RGB_BLUE);
                        break;
                    case WIDE_TEXT_LAYR:
                        rgb_matrix_set_color(index, RGB_YELLOW);
                        break;
                    case LOCK_LAYR:
                        break;
                    default:
                        rgb_matrix_set_color(index, 0x77, 0x77, 0x77);
                        break;
                    }
                }
            }
        }
// ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
        // custom colors for layer keys on fn layer
        if (layer == FN_LAYR) {
          rgb_matrix_set_color(I_LSFT, RGB_ORANGE); // left shift
          rgb_matrix_set_color(I_RSFT, RGB_ORANGE); // right shift
          rgb_matrix_set_color(I_LALT, RGB_RED);    // left alt / left cmd
          rgb_matrix_set_color(I_RALT, RGB_RED);    // right alt / right cmd 
          rgb_matrix_set_color(I_TAB, RGB_CYAN);    // tab
          rgb_matrix_set_color(I_LGUI, RGB_BLUE);   // left win / left opt 
        }
// ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~ 
        // custom colors for tap dance keys on symbol layer
        else if (layer == SYMBOL_LAYR || layer == MAC_SYMBOL_LAYR) {
          rgb_matrix_set_color(I_GRV, RGB_YELLOW); // grave
          rgb_matrix_set_color(I_1, RGB_YELLOW);   // 1
          rgb_matrix_set_color(I_E, RGB_YELLOW);   // e
          rgb_matrix_set_color(I_U, RGB_YELLOW);   // u
          rgb_matrix_set_color(I_I, RGB_YELLOW);   // i
          rgb_matrix_set_color(I_N, RGB_YELLOW);   // n
        }
// ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
        // set up the layer key blinking indicator
        if (!layer_timer) {
            is_led_on = true;
            layer_timer = timer_read();
        }
        // toggle an led light every 500 ms while the layer is active
        else if (timer_elapsed(layer_timer) > 500)
        {
            is_led_on = !is_led_on;
            layer_timer = timer_read();
        }
        // the led and color to flash on each layer to show the layer is active
        if (is_led_on)
        {
            switch (layer) {
            case FN_LAYR:
                rgb_matrix_set_color(I_CAPS, RGB_GREEN);  // caps
                rgb_matrix_set_color(I_FN, RGB_GREEN);    // fn
                break;
            case SFT_LAYR:
                rgb_matrix_set_color(I_LSFT, RGB_ORANGE); // lshift
                rgb_matrix_set_color(I_RSFT, RGB_ORANGE); // rshift
                break;
            case CTL_LAYR:
                rgb_matrix_set_color(I_LALT, RGB_RED);    // lalt
                rgb_matrix_set_color(I_RALT, RGB_RED);    // ralt
                break;
            case TMUX_LAYR:
                rgb_matrix_set_color(I_TAB, RGB_CYAN);    // tab
                break;
            case SYMBOL_LAYR:
                if (timer_elapsed(layer_timer) > 250) {
                    rgb_matrix_set_color(I_RALT, RGB_YELLOW); // ralt
                    rgb_matrix_set_color(I_LGUI, RGB_YELLOW); // lgui
                }
                else {
                    rgb_matrix_set_color(I_RALT, RGB_BLUE);   // ralt
                    rgb_matrix_set_color(I_LGUI, RGB_BLUE);   // lgui
                }
                break;
            case MAC_SYMBOL_LAYR:
                if (timer_elapsed(layer_timer) > 250) {
                    rgb_matrix_set_color(I_LOPT, RGB_YELLOW); // lopt
                    rgb_matrix_set_color(I_RCMD, RGB_YELLOW); // rcmd
                }
                else {
                    rgb_matrix_set_color(I_LOPT, RGB_BLUE);   // lopt
                    rgb_matrix_set_color(I_RCMD, RGB_BLUE);   // rcmd
                }
                break;
            case WIDE_TEXT_LAYR:
                rgb_matrix_set_color(I_RSFT, RGB_YELLOW);     // rshift
                break;
            }
        }
        // blink the indicator to show layer lock in on
        if (is_layer_locked(layer)) {
            if (!layer_lock_timer || timer_elapsed(layer_lock_timer) > 1000) {
                is_layer_lock_led_on = !is_layer_lock_led_on;
                layer_lock_timer = timer_read();
            }
            if (is_layer_lock_led_on) {
                rgb_matrix_set_color(I_LLOCK, 0x77, 0x77, 0x77); // just make it white 
            }
            else if ((timer_elapsed(layer_lock_timer) > 200 && timer_elapsed(layer_lock_timer) < 400) || 
                     (timer_elapsed(layer_lock_timer) > 600)) {
                rgb_matrix_set_color(I_LLOCK, 0x77, 0x77, 0x77); // white alternate with layer color 
            }
        }
    }
    else {
        rgb_matrix_set_color(I_FN, RGB_BLUE);        // fn
        rgb_matrix_set_color(I_TAB, 0x77,0x77,0x77); // tab
        // on windows, highlight the possible winkey shortcuts while winkey is held
        if (is_winkey_held) {
            for (int i = 0; i < winkey_scut_keys_size; i++) {
                rgb_matrix_set_color(winkey_scut_keys[i], 102, 178, 255);  // winkey shortcut keys
            }
            for (int i = 0; i < winkey_scut_altcolor_size; i++) {
                rgb_matrix_set_color(winkey_scut_altcolor[i], RGB_BLUE);    // winkey shortcut keys
            }
        }    
        if (!host_keyboard_led_state().caps_lock) {
          rgb_matrix_set_color(I_CAPS, RGB_BLUE);    // caps
        }
        // if caps lock, color caps alpha keys
        else {
           for (uint8_t i = led_min; i < led_max; i++) {
             if (is_capslock_shifted(i)) {
                rgb_matrix_set_color(i, RGB_RED);
             }
           }
        }
        // color caps word too
        if (is_caps_word_on())
        {
          // set capitilized keys red when caps word is active
          for (uint8_t i = led_min; i < led_max; i++) {
            if (is_capsword_shifted(i)) {
               rgb_matrix_set_color(i, RGB_RED);
            }
          }
          rgb_matrix_set_color(I_LSFT, 0x77, 0x77, 0x77); // turn left shift white when caps_word is active
          rgb_matrix_set_color(I_RSFT, 0x77, 0x77, 0x77); // turn right shift white when caps_word is active
        }
        // if not caps word, nor caps lock, then do the hrow colors if hrow_light setting is turned on       
        else if (!host_keyboard_led_state().caps_lock) { 
          if (hrow_light) {
              rgb_matrix_set_color(I_A, RGB_GREEN);    // a
              rgb_matrix_set_color(I_S, RGB_GREEN);    // s
              rgb_matrix_set_color(I_D, RGB_GREEN);    // d
              rgb_matrix_set_color(I_F, RGB_GREEN);    // f
              rgb_matrix_set_color(I_J, RGB_GREEN);    // j
              rgb_matrix_set_color(I_K, RGB_GREEN);    // k
              rgb_matrix_set_color(I_L, RGB_GREEN);    // l
              rgb_matrix_set_color(I_SEMI, RGB_GREEN); // ;
          }
          if (fj_light) {
              rgb_matrix_set_color(I_F, 0x77, 0x77, 0x77); // f
              rgb_matrix_set_color(I_J, 0x77, 0x77, 0x77); // j
          }
        }
    }
    // if key lock is watching for next key, flash the indicator yellow and orange
    if (is_key_lock_watching()) {
        if (!key_lock_timer || timer_elapsed(key_lock_timer) > 500) {
            is_key_lock_led_on = !is_key_lock_led_on;;
            key_lock_timer = timer_read();
        }
        if (is_key_lock_led_on) {
            rgb_matrix_set_color(I_INDICATOR, RGB_YELLOW);  // indicator 
        }
        else {
            rgb_matrix_set_color(I_INDICATOR, RGB_ORANGE);  // indicator 
        }
    }
    // if key lock is activated, flash the indicator white and red
    else if (is_key_locked) {
        if (!key_lock_timer || timer_elapsed(key_lock_timer) > 500) {
            is_key_lock_led_on = !is_key_lock_led_on;;
            key_lock_timer = timer_read();
        }
        if (is_key_lock_led_on) {
            rgb_matrix_set_color(I_INDICATOR, 0x77, 0x77, 0x77);   // indicator
        }
        else {
            rgb_matrix_set_color(I_INDICATOR, RGB_RED);   // indicator
        }
        // and light up normal modifiers if they are currently locked
        if (lctl_locked) {
            rgb_matrix_set_color(I_LCTL, 0x77, 0x77, 0x77);   // lctl
        }
        if (lalt_locked) {
            if (is_mac_base()) {
                rgb_matrix_set_color(I_LOPT, 0x77, 0x77, 0x77);   // lopt
            }
            else {
                rgb_matrix_set_color(I_LALT, 0x77, 0x77, 0x77);   // lalt
            }
        }
        if (lsft_locked) {
            rgb_matrix_set_color(I_LSFT, 0x77, 0x77, 0x77);   // lsft
        }
        if (lgui_locked) {
            if (is_mac_base()) {
                rgb_matrix_set_color(I_LCMD, 0x77, 0x77, 0x77);   // lcmd
            }
            else {
                rgb_matrix_set_color(I_LGUI, 0x77, 0x77, 0x77);   // lgui
            }
        }
        if (rsft_locked) {
            rgb_matrix_set_color(I_RSFT, 0x77, 0x77, 0x77);   // rsft
        }
        if (ralt_locked) {
            rgb_matrix_set_color(I_RALT, 0x77, 0x77, 0x77);    // ralt
        }
    }

    // check if a base layer change happened, and flash some indicators to show a change occured
    if (base_layer_changed) {
        if (!base_change_timer || timer_elapsed(base_change_timer) > 1300) {
            base_change_timer = timer_read();
        } 
        rgb_matrix_set_color(I_HOME, RGB_WHITE);                // home
        if (timer_elapsed(base_change_timer) > 300) {
            rgb_matrix_set_color(I_ENDPGUP, RGB_WHITE);         // pgup/end
        }
        if (timer_elapsed(base_change_timer) > 600) {
            rgb_matrix_set_color(I_PGUPPGDN, RGB_WHITE);        // pgdn/pgup 
        }
        if (timer_elapsed(base_change_timer) > 900) {
            rgb_matrix_set_color(I_PGDNEND, RGB_WHITE);         // end/pgdn
        }
        if (timer_elapsed(base_change_timer) > 1200) {
            base_layer_changed = false;
        }
    }    
    // check if mac/win change happened, and flash some indicators to show the change
    if (macwin_changed) {
        // turn off all currently lit leds first
        for (uint8_t i = led_min; i < led_max; i++) {
            rgb_matrix_set_color(i, 0x00, 0x00, 0x00);
        }
        int macwin_key1 = is_mac_base() ? I_M : I_W; 
        int macwin_key2 = is_mac_base() ? I_A : I_I; 
        int macwin_key3 = is_mac_base() ? I_C : I_N; 
        if (!macwin_change_timer || timer_elapsed(macwin_change_timer) > 1900) {
            macwin_change_timer = timer_read();
        } 
        rgb_matrix_set_color(macwin_key1, RGB_WHITE);           // M / W 
        if (timer_elapsed(macwin_change_timer) > 300) {
            rgb_matrix_set_color(macwin_key2, RGB_WHITE);       // A / I 
        }
        if (timer_elapsed(macwin_change_timer) > 600) {
            rgb_matrix_set_color(macwin_key3, RGB_WHITE);       // C / N 
        }
        if (timer_elapsed(macwin_change_timer) > 1800) {
            macwin_changed = false;
        }
    }

    if (is_in_leader_sequence) {
        if (!leader_timer || timer_elapsed(leader_timer) > 500) {
            is_leader_led_on = !is_leader_led_on;
            leader_timer = timer_read();
        }
        if (is_leader_led_on) {
            rgb_matrix_set_color(I_INDICATOR, RGB_TURQUOISE); // indicator 
            rgb_matrix_set_color(I_L, RGB_TURQUOISE);         // l
        }
        else {
            rgb_matrix_set_color(I_INDICATOR, RGB_CYAN);
            rgb_matrix_set_color(I_L, RGB_CYAN);
        }
    }
    // if a leader sequence error occured, blink all leds red
    else if (is_leader_error) {
        if (!leader_error_timer || timer_elapsed(leader_error_timer) > 250) {
            is_leader_error_led_on = !is_leader_error_led_on;
            leader_error_timer = timer_read();
        }
        if (is_leader_error_led_on) {
            for (uint8_t i = led_min; i < led_max; i++) {
                rgb_matrix_set_color(i, RGB_RED);
            }
        }
    }

    // if any rgb key highlights are on, turn the setting keys white on layer CTL_LAYR
    if (layer == CTL_LAYR)
    {
        if (fj_light) {
            rgb_matrix_set_color(I_FJLIGHT, RGB_WHITE);     // home (fj highlight key)
        }
        if (hrow_light) {
            rgb_matrix_set_color(I_HROWLIGHT, RGB_WHITE);   // end (hrow highlight key)
        }
        if (enable_keytracker) {
            rgb_matrix_set_color(I_SEMI, RGB_WHITE);        // semi (keytracker set key)
        }
    }

    // calculate the reactive rgb for keypresses
    if (enable_keytracker) {
        for (int i = 0; i < tk_length; i++) {
            if (tracked_keys[i].press) {
                rgb_matrix_set_color(tracked_keys[i].index, 255, 255, 255);
            }
            // do the key fade if key should fade
            // this is a modified fade to get a smoother look and be mostly white but a bit blue
            else if (key_should_fade(tracked_keys[i], layer)) {
                if (tracked_keys[i].fade > 255) {
                    rgb_matrix_set_color(tracked_keys[i].index, 255, 255, 255);
                } 
                else if (tracked_keys[i].fade > 230) {
                    rgb_matrix_set_color(tracked_keys[i].index, tracked_keys[i].fade, tracked_keys[i].fade, 255);
                } else {
                    rgb_matrix_set_color(tracked_keys[i].index, tracked_keys[i].fade, tracked_keys[i].fade, tracked_keys[i].fade + 25);
                }  
            }
        }
    }
    if (macro_recording) {
        // flash the indicator if macro is recording
        if (timer_elapsed(macro_timer) > 250) {
            is_macro_led_on = !is_macro_led_on;;
            macro_timer = timer_read();
        }
        if (is_macro_led_on) {
            rgb_matrix_set_color(I_INDICATOR, RGB_RED);   // indicator 
            if (macro_direction == 1) {
                rgb_matrix_set_color(I_MREC1, RGB_RED);   // [ macro1 record key
            }
            else {
                rgb_matrix_set_color(I_MREC2, RGB_RED);   // ] macro2 record key
            }
        }
        else {
            rgb_matrix_set_color(I_INDICATOR, 0, 0, 0);   // indicator 
            if (macro_direction == 1) {
                rgb_matrix_set_color(I_MREC1, 0, 0, 0);   // [ macro1 record key
            }
            else {
                rgb_matrix_set_color(I_MREC2, 0, 0, 0);   // ] macro2 record key
            }
        }
    }
    // if this is a color test, then light keys in each qmk named color
    if (color_test) {
        // turn off the color test if it has been going for 15 seconds
        if (timer_elapsed(color_test_timer) > 15000) {
            color_test = false;
        }
        else { // show the named colors defined in color.h, https://docs.qmk.fm/features/rgb_matrix
            rgb_matrix_set_color(I_Q, RGB_AZURE);
            rgb_matrix_set_color(I_W, RGB_BLACK);
            rgb_matrix_set_color(I_E, RGB_BLUE);
            rgb_matrix_set_color(I_R, RGB_CHARTREUSE);
            rgb_matrix_set_color(I_T, RGB_CORAL);
            rgb_matrix_set_color(I_Y, RGB_CYAN);
            rgb_matrix_set_color(I_U, RGB_GOLD);
            rgb_matrix_set_color(I_I, RGB_GOLDENROD);
            rgb_matrix_set_color(I_O, RGB_GREEN);
            rgb_matrix_set_color(I_P, RGB_MAGENTA);
            rgb_matrix_set_color(I_A, RGB_ORANGE);
            rgb_matrix_set_color(I_S, RGB_PINK);
            rgb_matrix_set_color(I_D, RGB_PURPLE);
            rgb_matrix_set_color(I_F, RGB_RED);
            rgb_matrix_set_color(I_G, RGB_SPRINGGREEN);
            rgb_matrix_set_color(I_H, RGB_TEAL);
            rgb_matrix_set_color(I_J, RGB_TURQUOISE);
            rgb_matrix_set_color(I_K, RGB_WHITE);
            rgb_matrix_set_color(I_L, RGB_YELLOW);
        }
    }
    // track if this is the middle of an accent key tap dance and illuminate the appropriate accent char
    if (act_char_led_index > 0) {
        rgb_matrix_set_color(act_char_led_index, RGB_WHITE);  // accent char led 
    } 
    // track mode keys on WIDE_TEXT_LAYR
    if (layer == WIDE_TEXT_LAYR) {
        if (wide_bartext) {
            rgb_matrix_set_color(I_BARTEXT, 0x77, 0x77, 0x77);  // bartext toggle
        }
        else if (wide_sthru) {
            rgb_matrix_set_color(I_STHRU, 0x77, 0x77, 0x77);    // sthru toggle
        }
        else if (wide_underln) {
            rgb_matrix_set_color(I_UNDERLN, 0x77, 0x77, 0x77);  // underln toggle
        }
    }
    // track caps_lock
    if (host_keyboard_led_state().caps_lock) {
        rgb_matrix_set_color(I_CAPS, 0x77, 0x77, 0x77);  // caps
    }
    // track num_lock
    if (layer == SFT_LAYR && host_keyboard_led_state().num_lock) {
        rgb_matrix_set_color(I_NUMLOCK, 0x77, 0x77, 0x77);
    }
    // track scroll_lock
    if (layer == FN_LAYR && host_keyboard_led_state().scroll_lock) {
        rgb_matrix_set_color(I_SLOCK, 0x77, 0x77, 0x77);
    }
        

// wireless connection indicators, setup in bridge75.c 
#    ifdef WIRELESS_ENABLE
    // CTL_LAYR will alwys show connection indicator; other layers for 4 seconds after wireless/battery keycode is used 
    if (layer == CTL_LAYR || (wls_action_timer && timer_elapsed32(wls_action_timer) < 4000)) {
        return true;
    }
#    endif
    return false;
}

// a function to check for if a key press should fade the rgb
bool key_should_fade(keytracker key, uint8_t layer) {
    bool should_fade = true;
    if ((key.fade < 1) ||
      ((layer == FN_LAYR || layer == SFT_LAYR || layer == WIDE_TEXT_LAYR || is_caps_word_on()) && 
        (key.index == I_LSFT || key.index == I_RSFT)) ||                                                         // l/r shift
      ((layer == FN_LAYR || layer == CTL_LAYR) && (key.index == I_LALT || key.index == I_RALT)) ||               // l/r alt
      (macro_recording && (key.index == I_MREC1 || key.index == I_MREC2)) ||                                     // macro recording keys
      (is_layer_locked(layer) && key.index == I_LLOCK) ||                                                        // home (layer lock key)
      (is_in_leader_sequence && key.index == I_L) ||                                                             // leader key
      (layer == SFT_LAYR && key.index == I_NUMLOCK) ||                                                           // num lock key
      (layer == FN_LAYR && key.index == I_SLOCK) ||                                                              // scroll lock
      (layer == WIDE_TEXT_LAYR && (key.index == I_BARTEXT || key.index == I_STHRU || key.index == I_UNDERLN)) || // wide-text mode toggles
      (layer == CTL_LAYR && (key.index == I_FJLIGHT || key.index == I_HROWLIGHT)) ||                             // hrow/fj indicators 
      (macwin_changed) ||                                                                                        // mac/win base change
      (layer == SYMBOL_LAYR && (key.index == I_GRV || key.index == I_1 || key.index == I_E ||
                                key.index == I_I || key.index == I_U || key.index == I_N ||                      // accent keys
                                key.index == I_RALT || key.index == I_LGUI)) ||                                  // sym_layr ralt and lgui 
      (key.index == I_CAPS) || (key.index == I_FN || key.index == I_TAB)) {                                      // caps lock, fn, and tab
        should_fade = false;
    }
    return should_fade;
}

// determine the current tap dance state
int cur_dance (tap_dance_state_t *state) {
  if (state->count == 1) {
    if (!state->pressed) {
        return SINGLE_TAP;
    } else {
        return SINGLE_HOLD;
    }
  } else if (state->count == 2) {
    if (!state->pressed) {
        return DOUBLE_TAP;
    } else {
        return DOUBLE_HOLD;
    }
  } else if (state->count == 3) {
    return TRIPLE_TAP;
  } else if (state->count == 4) {
    return QUAD_TAP;
  } else if (state->count == 5) {
    return PENT_TAP;
  } else if (state->count == 6) {
    return HEXA_TAP;
  }
  else return 9;
}

// initialize tap structure associated with each tap dance key
static tap caps_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap ralt_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap fn_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap rsft_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap kbunlock_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap actgrv_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap act1_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap acte_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap actu_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap acti_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap actn_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap lgui_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap rcmd_tap_state = {
  .is_press_action = true,
  .state = 0
};
static tap lopt_tap_state = {
  .is_press_action = true,
  .state = 0
};

// caps tap dance key function
void caps_finished (tap_dance_state_t *state, void *user_data) {
  caps_tap_state.state = cur_dance(state);
  switch (caps_tap_state.state) {
    case SINGLE_TAP:
      tap_code(KC_CAPS);
      break;
    case SINGLE_HOLD:
      layer_on(FN_LAYR);
      break;
    case DOUBLE_TAP:
      if (layer_state_is(FN_LAYR)) {
        //if already set, then switch it off
        layer_lock_off(FN_LAYR);
      } else {
        //if not already set, then switch the layer on
        layer_lock_on(FN_LAYR);
      }
      break;
    case TRIPLE_TAP:
      if (layer_state_is(SFT_LAYR)) {
        //if already set, then switch it off
        layer_lock_off(SFT_LAYR);
      } else {
        //if not already set, then switch the layer on
        layer_lock_on(SFT_LAYR);
      }
      break;
    case QUAD_TAP:
      if (layer_state_is(CTL_LAYR)) {
        //if already set, then switch it off
        layer_lock_off(CTL_LAYR);
      } else {
        //if not already set, then switch the layer on
        layer_lock_on(CTL_LAYR);
      }
      break;
    case PENT_TAP:
      if (layer_state_is(TMUX_LAYR)) {
        //if already set, then switch it off
        layer_lock_off(TMUX_LAYR);
      } else {
        //if not already set, then switch the layer on
        layer_lock_on(TMUX_LAYR);
      }
      break;
    case HEXA_TAP:
      if (!is_mac_base()) {
          if (layer_state_is(SYMBOL_LAYR)) {
            //if already set, then switch it off
            layer_lock_off(SYMBOL_LAYR);
          } else {
            //if not already set, then switch the layer on
            layer_lock_on(SYMBOL_LAYR);
          }
      }
      break;
  }
}
void caps_reset (tap_dance_state_t *state, void *user_data) {
  //if the key was held down and now is released then switch off the layer
  if (caps_tap_state.state==SINGLE_HOLD && !is_layer_locked(FN_LAYR)) {
    layer_off(FN_LAYR);
  }
  caps_tap_state.state = 0;
}

// function for ralt tap dance
void ralt_finished (tap_dance_state_t *state, void *user_data) {
  ralt_tap_state.state = cur_dance(state);
  switch (ralt_tap_state.state) {
    case SINGLE_TAP:
      set_oneshot_layer(CTL_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case SINGLE_HOLD:
      register_code(KC_RALT);
      break;
    case DOUBLE_TAP:
      set_oneshot_layer(SYMBOL_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case DOUBLE_HOLD:
      layer_on(SYMBOL_LAYR);  
      break;
  }
}
void ralt_reset (tap_dance_state_t *state, void *user_data) {
  switch (ralt_tap_state.state) {
    case SINGLE_TAP:
      break;
    case SINGLE_HOLD:
      unregister_code(KC_RALT);
      break;
    case DOUBLE_TAP:
      break;
    case DOUBLE_HOLD:
      if (!is_layer_locked(SYMBOL_LAYR)) {
        layer_off(SYMBOL_LAYR);
      }
      break;
  }
  ralt_tap_state.state = 0;
}

// function for rcmd tap dance
void rcmd_finished (tap_dance_state_t *state, void *user_data) {
  rcmd_tap_state.state = cur_dance(state);
  switch (rcmd_tap_state.state) {
    case SINGLE_TAP:
      set_oneshot_layer(CTL_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case SINGLE_HOLD:
      register_code(KC_RCMD);
      break;
    case DOUBLE_TAP:
      set_oneshot_layer(MAC_SYMBOL_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case DOUBLE_HOLD:
      layer_on(MAC_SYMBOL_LAYR);  
      break;
  }
}
void rcmd_reset (tap_dance_state_t *state, void *user_data) {
  switch (rcmd_tap_state.state) {
    case SINGLE_TAP:
      break;
    case SINGLE_HOLD:
      unregister_code(KC_RCMD);
      break;
    case DOUBLE_TAP:
      break;
    case DOUBLE_HOLD:
      if (!is_layer_locked(MAC_SYMBOL_LAYR)) {
        layer_off(MAC_SYMBOL_LAYR);
      }
      break;
  }
  rcmd_tap_state.state = 0;
}

// function for fn tap dance
void fn_finished (tap_dance_state_t *state, void *user_data) {
  fn_tap_state.state = cur_dance(state);
  switch (fn_tap_state.state) {
    case SINGLE_TAP:
      set_oneshot_layer(FN_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case SINGLE_HOLD:
      layer_on(FN_LAYR);
      break;
  }
}
void fn_reset (tap_dance_state_t *state, void *user_data) {
  switch (fn_tap_state.state) {
    case SINGLE_TAP:
      break;
    case SINGLE_HOLD:
      if (!is_layer_locked(FN_LAYR)) {
        layer_off(FN_LAYR);
      }
      break;
  }
  fn_tap_state.state = 0;
}

// function for each press of rsft
// this is needed so that pressing both shifts will activate caps_word, even when one of the shifts is a tap dance
void rsft_each(tap_dance_state_t *state, void *user_data) {
    if (get_mods() & MOD_BIT(KC_LSFT)) {
        caps_word_on();
    }
}
// function for rsft tap dance
void rsft_finished (tap_dance_state_t *state, void *user_data) {
  rsft_tap_state.state = cur_dance(state);
  switch (rsft_tap_state.state) {
    case SINGLE_TAP:
      // check if this is caps word activation, otherwise set the osl
      if (!is_caps_word_on()) {
          set_oneshot_layer(SFT_LAYR, ONESHOT_START);
          clear_oneshot_layer_state(ONESHOT_PRESSED);
      }
      break;
    case DOUBLE_TAP:
      // activate WIDE_TEXT_LAYR
      if (IS_LAYER_ON(WIDE_TEXT_LAYR)) {
          layer_lock_off(WIDE_TEXT_LAYR);
      }
      else {
          layer_lock_on(WIDE_TEXT_LAYR);
      }
      break;
    case SINGLE_HOLD:
      // check if this is caps word activation, otherwise regular shift
      if (get_mods() & MOD_BIT(KC_LSFT)) {
          caps_word_on();
      }
      else {
          register_code(KC_RSFT);
      }
      break;
  }
}
void rsft_reset (tap_dance_state_t *state, void *user_data) {
  switch (rsft_tap_state.state) {
    case SINGLE_TAP:
      // check if this is caps word activation
      if (get_mods() & MOD_BIT(KC_LSFT)) {
          reset_oneshot_layer();
          caps_word_on();
      }
      break;
    case DOUBLE_TAP:
      break;
    case SINGLE_HOLD:
      if (get_mods() & MOD_BIT(KC_LSFT)) {
          caps_word_on();
      }
      else {
          unregister_code(KC_RSFT);
      }
      break;
  }
  rsft_tap_state.state = 0;
}

// function for kbunlock tap dance
void kbunlock_finished (tap_dance_state_t *state, void *user_data) {
  kbunlock_tap_state.state = cur_dance(state);
  switch (kbunlock_tap_state.state) {
    case SINGLE_TAP:
      break;
    case DOUBLE_TAP:
      break;
    case TRIPLE_TAP:
      layer_off(LOCK_LAYR); // three taps unlocks the LOCK_LAYER
      break;
    case SINGLE_HOLD:
      break;
  }
}
void kbunlock_reset (tap_dance_state_t *state, void *user_data) {
  kbunlock_tap_state.state = 0;
}

// function for each press of grv on symbol layer
void actgrv_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_A;
            break;
        case 2:
            act_char_led_index = I_E;
            break;
        case 3:
            act_char_led_index = I_I;
            break;
        case 4:
            act_char_led_index = I_O;
            break;
        case 5:
            act_char_led_index = I_U;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer grv key tap dance
void actgrv_finished (tap_dance_state_t *state, void *user_data) {
  actgrv_tap_state.state = cur_dance(state);
  switch (actgrv_tap_state.state) {
    case SINGLE_TAP:
      symbol_key("0224","0192"); // a
      break;
    case DOUBLE_TAP:
      symbol_key("0232","0200"); // e
      break;
    case TRIPLE_TAP:
      symbol_key("0236","0204"); // i
      break;
    case QUAD_TAP:
      symbol_key("0242","0210"); // o
      break;
    case PENT_TAP:
      symbol_key("0249","0217"); // u
      break;
    case HEXA_TAP:
      break;
  }
}
void actgrv_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    actgrv_tap_state.state = 0;
}

// function for each press of 1 on symbol layer
void act1_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_1;
            break;
        case 2:
            act_char_led_index = I_2;
            break;
        case 3:
            act_char_led_index = I_3;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer 1 key tap dance
void act1_finished (tap_dance_state_t *state, void *user_data) {
  act1_tap_state.state = cur_dance(state);
  switch (act1_tap_state.state) {
    case SINGLE_TAP:
      symbol_key("173","0188");  // inverted ! or 1/4 
      break;
    case DOUBLE_TAP:
      symbol_key("0189","0189"); // 1/2 
      break;
    case TRIPLE_TAP:
      symbol_key("0190","0190"); // 3/4
      break;
    case QUAD_TAP:
      break;
    case PENT_TAP:
      break;
    case HEXA_TAP:
      break;
  }
}
void act1_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    act1_tap_state.state = 0;
}

// function for each press of e on symbol layer
void acte_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_E;
            break;
        case 2:
            act_char_led_index = I_A;
            break;
        case 3:
            act_char_led_index = I_I;
            break;
        case 4:
            act_char_led_index = I_O;
            break;
        case 5:
            act_char_led_index = I_U;
            break;
        case 6:
            act_char_led_index = I_Y;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer e key tap dance
void acte_finished (tap_dance_state_t *state, void *user_data) {
  acte_tap_state.state = cur_dance(state);
  switch (acte_tap_state.state) {
    case SINGLE_TAP:
      symbol_key("0233","0201"); // e 
      break;
    case DOUBLE_TAP:
      symbol_key("0225","0193"); // a 
      break;
    case TRIPLE_TAP:
      symbol_key("0237","0205"); // i 
      break;
    case QUAD_TAP:
      symbol_key("0243","0211"); // o 
      break;
    case PENT_TAP:
      symbol_key("0250","0218"); // u 
      break;
    case HEXA_TAP:
      symbol_key("0253","0221"); // y 
      break;
  }
}
void acte_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    acte_tap_state.state = 0;
}

// function for each press of u on symbol layer
void actu_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_A;
            break;
        case 2:
            act_char_led_index = I_E;
            break;
        case 3:
            act_char_led_index = I_I;
            break;
        case 4:
            act_char_led_index = I_O;
            break;
        case 5:
            act_char_led_index = I_U;
            break;
        case 6:
            act_char_led_index = I_Y;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer u key tap dance
void actu_finished (tap_dance_state_t *state, void *user_data) {
  actu_tap_state.state = cur_dance(state);
  switch (actu_tap_state.state) {
    case SINGLE_TAP:
      symbol_key("0228","0196"); // a 
      break;
    case DOUBLE_TAP:
      symbol_key("0235","0203"); // e 
      break;
    case TRIPLE_TAP:
      symbol_key("0239","0207"); // i 
      break;
    case QUAD_TAP:
      symbol_key("0246","0214"); // o 
      break;
    case PENT_TAP:
      symbol_key("0252","0220"); // u 
      break;
    case HEXA_TAP:
      symbol_key("0255","0159"); // y 
      break;
  }
}
void actu_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    actu_tap_state.state = 0;
}

// function for each press of i on symbol layer
void acti_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_I;
            break;
        case 2:
            act_char_led_index = I_A;
            break;
        case 3:
            act_char_led_index = I_E;
            break;
        case 4:
            act_char_led_index = I_O;
            break;
        case 5:
            act_char_led_index = I_U;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer i key tap dance
void acti_finished (tap_dance_state_t *state, void *user_data) {
  acti_tap_state.state = cur_dance(state);
  switch (acti_tap_state.state) {
    case SINGLE_TAP:
      symbol_key("0238","0206"); // i 
      break;
    case DOUBLE_TAP:
      symbol_key("0226","0194"); // a 
      break;
    case TRIPLE_TAP:
      symbol_key("0234","0202"); // e 
      break;
    case QUAD_TAP:
      symbol_key("0244","0212"); // o 
      break;
    case PENT_TAP:
      symbol_key("0251","0219"); // u 
      break;
    case HEXA_TAP:
      break;
  }
}
void acti_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    acti_tap_state.state = 0;
}

// function for each press of n on symbol layer
void actn_each(tap_dance_state_t *state, void *user_data) {
    switch (state->count) {
        case 1:
            act_char_led_index = I_N;
            break;
        case 2:
            act_char_led_index = I_A;
            break;
        case 3:
            act_char_led_index = I_O;
            break;
        default:
            act_char_led_index = 0;
            break;
    }
}
// function for symbol layer n key tap dance
void actn_finished (tap_dance_state_t *state, void *user_data) {
  actn_tap_state.state = cur_dance(state);
  switch (actn_tap_state.state) {
    case SINGLE_TAP:
      symbol_key("164","165");   // n 
      break;
    case DOUBLE_TAP:
      symbol_key("0227","0195"); // a 
      break;
    case TRIPLE_TAP:
      symbol_key("0245","0213"); // o 
      break;
  }
}
void actn_reset (tap_dance_state_t *state, void *user_data) {
    act_char_led_index = 0;
    actn_tap_state.state = 0;
}

// function for lgui tap dance
void lgui_finished (tap_dance_state_t *state, void *user_data) {
  lgui_tap_state.state = cur_dance(state);
  switch (lgui_tap_state.state) {
    case SINGLE_TAP:
      tap_code(KC_LGUI);
      break;
    case SINGLE_HOLD:
      register_code(KC_LGUI);
      if (!is_mac_base()) {
        is_winkey_held = true;
      }
      break;
    case DOUBLE_TAP:
      set_oneshot_layer(SYMBOL_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case DOUBLE_HOLD:
      layer_on(SYMBOL_LAYR);  
      break;
  }
}
void lgui_reset (tap_dance_state_t *state, void *user_data) {
  switch (lgui_tap_state.state) {
    case SINGLE_TAP:
      break;
    case SINGLE_HOLD:
      unregister_code(KC_LGUI);
      if (!is_mac_base()) {
        is_winkey_held = false;
      }
      break;
    case DOUBLE_TAP:
      break;
    case DOUBLE_HOLD:
      if (!is_layer_locked(SYMBOL_LAYR)) {
        layer_off(SYMBOL_LAYR);
      }
      break;
  }
  lgui_tap_state.state = 0;
}

// function for lopt tap dance
void lopt_finished (tap_dance_state_t *state, void *user_data) {
  lopt_tap_state.state = cur_dance(state);
  switch (lopt_tap_state.state) {
    case SINGLE_TAP:
      tap_code(KC_LOPT);
      break;
    case SINGLE_HOLD:
      register_code(KC_LOPT);
      break;
    case DOUBLE_TAP:
      set_oneshot_layer(MAC_SYMBOL_LAYR, ONESHOT_START);
      clear_oneshot_layer_state(ONESHOT_PRESSED);
      break;
    case DOUBLE_HOLD:
      layer_on(MAC_SYMBOL_LAYR);  
      break;
  }
}
void lopt_reset (tap_dance_state_t *state, void *user_data) {
  switch (lopt_tap_state.state) {
    case SINGLE_TAP:
      break;
    case SINGLE_HOLD:
      unregister_code(KC_LOPT);
      break;
    case DOUBLE_TAP:
      break;
    case DOUBLE_HOLD:
      if (!is_layer_locked(MAC_SYMBOL_LAYR)) {
        layer_off(MAC_SYMBOL_LAYR);
      }
      break;
  }
  lopt_tap_state.state = 0;
}

// associate the tap dance keys with their funcitons
tap_dance_action_t tap_dance_actions[] = {
  [CAPS_LAYR] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, caps_finished, caps_reset),
  [FN_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, fn_finished, fn_reset),
  [RALT_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, ralt_finished, ralt_reset),
  [RSFT_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(rsft_each, rsft_finished, rsft_reset),
  [KB_UNLOCK] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, kbunlock_finished, kbunlock_reset),
  [ACT_GRV] = ACTION_TAP_DANCE_FN_ADVANCED(actgrv_each, actgrv_finished, actgrv_reset),
  [ACT_1] = ACTION_TAP_DANCE_FN_ADVANCED(act1_each, act1_finished, act1_reset),
  [ACT_E] = ACTION_TAP_DANCE_FN_ADVANCED(acte_each, acte_finished, acte_reset),
  [ACT_U] = ACTION_TAP_DANCE_FN_ADVANCED(actu_each, actu_finished, actu_reset),
  [ACT_I] = ACTION_TAP_DANCE_FN_ADVANCED(acti_each, acti_finished, acti_reset),
  [ACT_N] = ACTION_TAP_DANCE_FN_ADVANCED(actn_each, actn_finished, actn_reset),
  [LGUI_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, lgui_finished, lgui_reset),
  [RCMD_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, rcmd_finished, rcmd_reset),
  [LOPT_OSL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, lopt_finished, lopt_reset),
};

// accent tap dances should give a little bit longer to see the leds
uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case TD(ACT_GRV):
        case TD(ACT_1):
        case TD(ACT_E):
        case TD(ACT_U):
        case TD(ACT_I):
        case TD(ACT_N):
            return TAPPING_TERM + 400;
        default:
            return TAPPING_TERM;
    }
}

// this is needed to prevent CAPS_WORD from breaking when some custom key commands are used
bool caps_word_press_user(uint16_t keycode) {
    switch (keycode) {
        // Keycodes that continue Caps Word, with shift applied.
        case KC_A ... KC_Z:
        case KC_MINS:
            add_weak_mods(MOD_BIT(KC_LSFT));  // Apply shift to next key.
            return true;

        // Keycodes that continue Caps Word, without shifting.
        case KC_1 ... KC_0:
        case KC_BSPC:
        case KC_DEL:
        case KC_UNDS:
        case BSPCFAST:
            return true;

        default:
            return false;  // Deactivate Caps Word.
    }
}

// setup to store vars when macro recording starts or ends. then can flash some rgb
bool dynamic_macro_record_start_user(int8_t direction) {
    macro_direction = direction;
    macro_recording = true;
    macro_timer = timer_read();
    return true;
}
bool dynamic_macro_record_end_user(int8_t direction) {
    macro_direction = direction;
    macro_recording = false;
    is_macro_led_on = false;
    // this loop is needed to prevent a stuck led after a macro finishes recording
    for (int i = 0; i < tk_length; i++) {
        if (tracked_keys[i].index == I_MREC1 || tracked_keys[i].index == I_MREC2) {
            tracked_keys[i].press = false;
            tracked_keys[i].fade = 0;
        }
    }
    return true;
}
// this is so the macro key lights don't get stuck when i play the macro
bool dynamic_macro_play_user(int8_t direction) {
    for (int i = 0; i < tk_length; i++) {
        if (tracked_keys[i].index == I_MPLY1 || tracked_keys[i].index == I_MPLY2) {
            tracked_keys[i].press = false;
            tracked_keys[i].fade = 0;
        }
    }
    return true;
}

void oneshot_layer_changed_user(uint8_t layer) {
    if (layer > 1) {
        oneshot_layer_active = true;
    }
    if (!layer) {
        oneshot_layer_active = false;
    }
}

void leader_start_user(void) {
    is_in_leader_sequence = true;
}

void leader_end_user(void) {
    if (leader_sequence_three_keys(KC_L, KC_L, KC_S)) {        // layer lock SFT_LAYR
        if (is_layer_locked(SFT_LAYR)) {
            layer_lock_off(SFT_LAYR);
        }
        else {
            layer_lock_on(SFT_LAYR);
        }
    }
    else if (leader_sequence_three_keys(KC_L, KC_L, KC_A)) {   // layer lock CTL_LAYR (now on ALT key)
        if (is_layer_locked(CTL_LAYR)) {
            layer_lock_off(CTL_LAYR);
        }
        else {
            layer_lock_on(CTL_LAYR);
        }
    }
    else if (leader_sequence_three_keys(KC_L, KC_L, KC_F)) {   // layer lock FN_LAYR
        if (is_layer_locked(FN_LAYR)) {
            layer_lock_off(FN_LAYR);
        }
        else {
            layer_lock_on(FN_LAYR);
        }
    }
    else if (leader_sequence_three_keys(KC_L, KC_L, KC_T)) {   // layer lock TMUX_LAYR
        if (is_layer_locked(TMUX_LAYR)) {
            layer_lock_off(TMUX_LAYR);
        }
        else {
            layer_lock_on(TMUX_LAYR);
        }
    }
    else if (leader_sequence_four_keys(KC_L, KC_L, KC_S, KC_M)) {   // layer lock SYMBOL_LAYR
        if (is_mac_base()) {
            if (is_layer_locked(MAC_SYMBOL_LAYR)) {
                layer_lock_off(MAC_SYMBOL_LAYR);
            }
            else {
                layer_lock_on(MAC_SYMBOL_LAYR);
            }
        }
        else {
            if (is_layer_locked(SYMBOL_LAYR)) {
                layer_lock_off(SYMBOL_LAYR);
            }
            else {
                layer_lock_on(SYMBOL_LAYR);
            }
        }
    }
    else if (leader_sequence_four_keys(KC_L, KC_O, KC_C, KC_K)) {   // switch to LOCK_LAYR
        layer_on(LOCK_LAYR);
    }
    else if (leader_sequence_two_keys(KC_L, KC_K)) {                // set key lock watch
        set_key_lock_watching();
    }
    else if (leader_sequence_two_keys(KC_O, KC_S)) {                 // change os
        if (is_mac_base()) {
            set_single_persistent_default_layer(BASE2_LAYR);
            layer_move(BASE2_LAYR);
        }
        else {
            set_single_persistent_default_layer(MAC_BASE2_LAYR);
            layer_move(MAC_BASE2_LAYR);
        }
        macwin_changed = true;
    }
    else if (leader_sequence_four_keys(KC_B, KC_A, KC_S, KC_E)) {   // change default BASE layer
        int b_layer = is_mac_base() ? MAC_BASE_LAYR : BASE_LAYR;
        int b2_layer = is_mac_base() ? MAC_BASE2_LAYR : BASE2_LAYR;
        if (IS_LAYER_ON(b_layer))
        {
            set_single_persistent_default_layer(b2_layer);
            layer_move(b2_layer);
        }
        else
        {
            set_single_persistent_default_layer(b_layer);
            layer_move(b_layer);
        }
        base_layer_changed = true;
    }
    else if (leader_sequence_five_keys(KC_C, KC_O, KC_L, KC_O, KC_R)) { // start the color test
        color_test_timer = timer_read();
        color_test = true;
    }
    else if (leader_sequence_two_keys(KC_R, KC_T)) {          // rpi temp monitor
        SEND_STRING("rpi/temperature.sh" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_R, KC_U)) {          // rpi uptime monitor
        SEND_STRING("rpi/uptime.sh" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_P, KC_R)) {          // restart pi-hole
        SEND_STRING("sudo service pihole-FTL restart" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_M, KC_A)) {          // sudo mount -a
        SEND_STRING("sudo mount -a" SS_TAP(X_ENT));
    }
    else if (leader_sequence_three_keys(KC_P, KC_O, KC_C)) {  // insert test POC data for template
        send_string_with_delay("Firstname" SS_TAP(X_TAB) "Lastname" SS_TAP(X_TAB) "123-456-7890" SS_TAP(X_TAB) "first.last@mail.mil" SS_TAP(X_TAB),10);
    }
    else if (leader_sequence_two_keys(KC_N, KC_1)) {          // mac mini start nut upsdrvctl
        SEND_STRING("sudo /usr/local/opt/nut/sbin/upsdrvctl start" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_N, KC_2)) {          // mac mini start nut upsd
        SEND_STRING("sudo /usr/local/opt/nut/sbin/upsd" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_N, KC_R)) {          // restart nut
        SEND_STRING("sudo service nut-server restart" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_U, KC_R)) {          // restart unifi
        SEND_STRING("sudo service unifi restart" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_U, KC_U)) {          // update unifi
        if (is_mac_base()) {  
          SEND_STRING("wget https://get.glennr.nl/unifi/update/unifi-update.sh && sudo bash unifi-update.sh --custom-url " SS_LCMD(SS_TAP(X_V)) SS_TAP(X_ENT));
        }   
        else {  
          SEND_STRING("wget https://get.glennr.nl/unifi/update/unifi-update.sh && sudo bash unifi-update.sh --custom-url " SS_LCTL(SS_TAP(X_V)) SS_TAP(X_ENT));
        }
    }
    else if (leader_sequence_two_keys(KC_V, KC_H)) {          // open hosts file in vi
        SEND_STRING("sudo vi /etc/hosts" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_V, KC_A)) {          // open tb authorized in vi
        SEND_STRING("sudo vi /sys/bus/thunderbolt/devices/0-3/authorized" SS_TAP(X_ENT));
    }
    else if (leader_sequence_two_keys(KC_S, KC_W)) {          // select word
        SEND_STRING(SS_LCTL(SS_TAP(X_LEFT) SS_LSFT(SS_TAP(X_RIGHT))));
    }
    else if (leader_sequence_two_keys(KC_S, KC_L)) {          // select line
        SEND_STRING(SS_TAP(X_HOME) SS_LSFT(SS_TAP(X_END)));
    }
    else if (leader_sequence_two_keys(KC_T, KC_Y)) {          // thank you
        SEND_STRING("thank you");
    }
    else if (leader_sequence_two_keys(KC_N, KC_P)) {          // no problem
        SEND_STRING("no problem");
    }
    else if (leader_sequence_three_keys(KC_O, KC_M, KC_W)) {  // on my way
        SEND_STRING("on my way");
    }
    else if (leader_sequence_three_keys(KC_B, KC_R, KC_B)) {  // be right back
        SEND_STRING("be right back");
    }
    else if (leader_sequence_three_keys(KC_H, KC_G, KC_E)) {  // have a good evening 
        SEND_STRING("have a good evening");
    }
    else if (leader_sequence_three_keys(KC_H, KC_G, KC_N)) {  // have a good night 
        SEND_STRING("have a good night");
    }
    else if (leader_sequence_four_keys(KC_T, KC_T, KC_Y, KC_L)) {  // talk to you later
        SEND_STRING("talk to you later");
    }
    else if (leader_sequence_four_keys(KC_G, KC_I, KC_T, KC_L)) {        // git log
        SEND_STRING("git log\n");
    }
    else if (leader_sequence_four_keys(KC_G, KC_I, KC_T, KC_A)) {        // git add
        SEND_STRING("git add -A\n");
    }
    else if (leader_sequence_four_keys(KC_G, KC_I, KC_T, KC_C)) {        // git commit
        SEND_STRING("git commit -m \"\"" SS_TAP(X_LEFT));
    }
    else if (leader_sequence_four_keys(KC_G, KC_I, KC_T, KC_P)) {        // git push
        SEND_STRING("git push\n");
    }
    else if (leader_sequence_five_keys(KC_G, KC_I, KC_T, KC_C, KC_O)) {  // git checkout .
        SEND_STRING("git checkout .\n");
    }
    else if (leader_sequence_three_keys(KC_Q, KC_C, KC_B)) {  // qmk compile shortcutstudio bridge75 firmware
        SEND_STRING("qmk compile -kb shortcut/bridge75 -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_three_keys(KC_Q, KC_F, KC_B)) {  // qmk flash shortcutstudio bridge75 firmware
        SEND_STRING("qmk flash -kb shortcut/bridge75 -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_three_keys(KC_Q, KC_C, KC_Y)) {  // qmk compile yunzii firmware
        SEND_STRING("qmk compile -kb yunzii/al68 -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_three_keys(KC_Q, KC_F, KC_Y)) {  // qmk flash yunzii firmware
        SEND_STRING("qmk flash -kb yunzii/al68 -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_four_keys(KC_Q, KC_C, KC_K, KC_V)) {  // qmk compile keychron V6 firmware
        SEND_STRING("qmk compile -kb keychron/v6_max/ansi_encoder -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_four_keys(KC_Q, KC_F, KC_K, KC_V)) {  // qmk flash keychron V6 firmware
        SEND_STRING("qmk flash -kb keychron/v6_max/ansi_encoder -km djcastaldo" SS_TAP(X_ENT));
    }                       
    else if (leader_sequence_four_keys(KC_Q, KC_C, KC_K, KC_Q)) {  // qmk compile keychron Q6 firmware
        SEND_STRING("qmk compile -kb keychron/q6_max/ansi_encoder -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_four_keys(KC_Q, KC_F, KC_K, KC_Q)) {  // qmk flash keychron Q6 firmware
        SEND_STRING("qmk flash -kb keychron/q6_max/ansi_encoder -km djcastaldo" SS_TAP(X_ENT));
    }
    else if (leader_sequence_five_keys(KC_A, KC_S, KC_P, KC_D, KC_C)) {  // asp.net decrypt connectionStrings path from clipboard
        send_string_with_delay("C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\aspnet_regiis -pdf connectionStrings " SS_LCTL(SS_TAP(X_V)) SS_TAP(X_ENT),9);
    }
    else if (leader_sequence_five_keys(KC_A, KC_S, KC_P, KC_E, KC_C)) {  // asp.net encrypt connectionStrings path from clipboard
        send_string_with_delay("C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\aspnet_regiis -pef connectionStrings " SS_LCTL(SS_TAP(X_V)) SS_TAP(X_ENT),9);
    }
    else if (leader_sequence_five_keys(KC_A, KC_S, KC_P, KC_D, KC_S)) {  // asp.net decrypt sessionState path from clipboard
        send_string_with_delay("C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\aspnet_regiis -pdf system.web/sessionState " SS_LCTL(SS_TAP(X_V)) SS_TAP(X_ENT),9);
    }
    else if (leader_sequence_five_keys(KC_A, KC_S, KC_P, KC_E, KC_S)) {  // asp.net encrypt sessionState path from clipboard
        send_string_with_delay("C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\aspnet_regiis -pef system.web/sessionState " SS_LCTL(SS_TAP(X_V)) SS_TAP(X_ENT),9);
    }
    // if process_leader_secrets returns false, a secret leader sequence ran and leader matching should stop
    // if true, no secrets match and leader matching continues here.
    else if (process_leader_secrets()) {
        // leader sequence failed, so blink the rgb red a few times
        is_leader_error = true;
        leader_error_token = defer_exec(1500, leader_error_callback, NULL);  // Schedule callback.
    }

    is_in_leader_sequence = false;
}
